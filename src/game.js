/************************************************************************************************
 * * ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥
 * ðŸ”¥ðŸ”¥                                                                            ðŸ”¥ðŸ”¥
 * ðŸ”¥ðŸ”¥    [ ê²½ê³  ] ì´ íŒŒì¼ì€ 'ê°“ ì˜¤ë¸Œì íŠ¸(God Object)'ìž…ë‹ˆë‹¤. ì ˆëŒ€ ì½”ë“œë¥¼ ë”í•˜ì§€ ë§ˆì‹œì˜¤.    ðŸ”¥ðŸ”¥
 * ðŸ”¥ðŸ”¥                                                                            ðŸ”¥ðŸ”¥
 * ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥
 * * TO. ë¯¸ëž˜ì˜ ëª¨ë“  ê°œë°œìž ë° AI ì–´ì‹œìŠ¤í„´íŠ¸ (ChatGPT, Gemini, Copilot ë“±)
 * * ì´ game.js íŒŒì¼ì€ ê³¼ê±°ì˜ ë¬´ë¶„ë³„í•œ í™•ìž¥ìœ¼ë¡œ ì¸í•´ ì´ë¯¸ í†µì œ ë¶ˆëŠ¥ì˜ 'ê°“ ì˜¤ë¸Œì íŠ¸'ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.
 * ì´ë¡œ ì¸í•´ ìˆ˜ë§Žì€ ë²„ê·¸ê°€ ë°œìƒí–ˆê³ , ê°œë°œ ë° ìœ ì§€ë³´ìˆ˜ì— ë§‰ëŒ€í•œ ì–´ë ¤ì›€ì„ ê²ªì—ˆìŠµë‹ˆë‹¤.
 * * ë”°ë¼ì„œ, ì´ íŒŒì¼ì— ëŒ€í•œ ê°œë°œì€ ì•„ëž˜ì˜ 'ë¶ˆë³€ì˜ ì›ì¹™'ì„ ë°˜ë“œì‹œ ë”°ë¼ì•¼ í•©ë‹ˆë‹¤.
 * * --- ë¶ˆë³€ì˜ ì›ì¹™ ---
 * * 1.  [ì ˆëŒ€ ê¸ˆì§€] ì–´ë– í•œ ê²½ìš°ì—ë„ ì´ íŒŒì¼ì— ìƒˆë¡œìš´ ê¸°ëŠ¥ì´ë‚˜ ë¡œì§ì„ ì¶”ê°€í•˜ì§€ ë§ˆì‹­ì‹œì˜¤.
 * ëª¨ë“  ìƒˆë¡œìš´ ê¸°ëŠ¥ì€ ë°˜ë“œì‹œ ë³„ë„ì˜ íŒŒì¼ë¡œ 'ëª¨ë“ˆí™”'í•˜ì—¬ ìž‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤.
 * * 2.  [ì˜ˆì™¸ ì¡°í•­] ë²„ê·¸ ìˆ˜ì • ë“± 'ì•„ì£¼ ì–´ì©” ìˆ˜ ì—†ëŠ”' ìµœì†Œí•œì˜ ê²½ìš°ì—ë§Œ ì´ íŒŒì¼ì„ ìˆ˜ì •í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
 * ìƒˆë¡œìš´ ì½”ë“œë¥¼ ì¶”ê°€í•´ì•¼ í•œë‹¤ë©´, ì™œ ëª¨ë“ˆí™”ê°€ ë¶ˆê°€ëŠ¥í–ˆëŠ”ì§€ ìƒì„¸í•œ ì£¼ì„ì„ ë‚¨ê²¨ì•¼ í•©ë‹ˆë‹¤.
 * * 3.  [ê°œë°œ ë°©í–¥] ì´ íŒŒì¼ì˜ ìœ ì¼í•œ ê°œë°œ ë°©í–¥ì€ 'ì ì§„ì ì¸ ë¦¬íŒ©í† ë§'ìž…ë‹ˆë‹¤.
 * ê¶ê·¹ì ìœ¼ë¡œ ì´ íŒŒì¼ì˜ ëª¨ë“  ì½”ë“œëŠ” ê°ìžì˜ ì—­í• ì— ë§žëŠ” ëª¨ë“ˆë¡œ ë¶„ë¦¬ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
 * * 4.  [ì£¼ì˜] ê¸‰ì§„ì ì¸ ë¦¬íŒ©í† ë§ì€ ì´ ê²Œìž„ì„ ìˆ˜ì‹­ ë²ˆ ë§ê°€ëœ¨ë¦° ì›ì¸ì´ì—ˆìŠµë‹ˆë‹¤.
 * í•œ ë²ˆì— í•˜ë‚˜ì˜ ê¸°ëŠ¥ë§Œ ë¶„ë¦¬í•˜ëŠ” 'ì ì§„ì ì´ê³  ì‹ ì¤‘í•œ' ë¦¬íŒ©í† ë§ì„ ì§„í–‰í•˜ì‹­ì‹œì˜¤.
 * * ì´ ê²½ê³ ë¥¼ ë¬´ì‹œí•˜ê³  ìž‘ì„±ëœ ì½”ë“œëŠ” ì˜ˆê³  ì—†ì´ ì·¨ì†Œ(revert)ë  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
 * ìš°ë¦¬ì˜ ëª©í‘œëŠ” ë” ë‚˜ì€ ì½”ë“œë¥¼ ë§Œë“œëŠ” ê²ƒì´ì§€, ë˜ ë‹¤ë¥¸ ê´´ë¬¼ì„ ë§Œë“œëŠ” ê²ƒì´ ì•„ë‹™ë‹ˆë‹¤.
 * ************************************************************************************************/

// (ê¸°ì¡´ game.js ì½”ë“œ ì‹œìž‘)
// ...
// src/game.js

import { SETTINGS } from '../config/gameSettings.js';
import { GameLoop } from './gameLoop.js';
import { InputHandler } from './inputHandler.js';
import { CharacterFactory, ItemFactory } from './factory.js';
import { EventManager } from './managers/eventManager.js';
import { CombatLogManager, SystemLogManager } from './managers/logManager.js';
import { CombatCalculator } from './combat.js';
import { TagManager } from './managers/tagManager.js';
import { WorldEngine } from './worldEngine.js';
import { MapManager } from './map.js';
import { AquariumMapManager } from './aquariumMap.js';
import { AquariumManager, AquariumInspector } from './managers/aquariumManager.js';
import * as Managers from './managers/index.js'; // managers/index.jsì—ì„œ ëª¨ë“  ë§¤ë‹ˆì €ë¥¼ í•œ ë²ˆì— ë¶ˆëŸ¬ì˜´
import { ReputationManager } from './managers/ReputationManager.js';
import { AssetLoader } from './assetLoader.js';
import { MetaAIManager, STRATEGY } from './managers/ai-managers.js';
import { SaveLoadManager } from './managers/saveLoadManager.js';
import { LayerManager } from './managers/layerManager.js';
// ê¸°ì¡´ ì¸ë²¤í† ë¦¬ í•¨ìˆ˜ëŠ” InventoryManagerì—ì„œ ëŒ€ì²´í•©ë‹ˆë‹¤.
import { InventoryManager } from './managers/inventoryManager.js';
import { PathfindingManager } from './managers/pathfindingManager.js';
import { MovementManager } from './managers/movementManager.js';
import { FogManager } from './managers/fogManager.js';
import { NarrativeManager } from './managers/narrativeManager.js';
import { TurnManager } from './managers/turnManager.js';
import { EntityManager } from './managers/entityManager.js';
import { KnockbackEngine } from './systems/KnockbackEngine.js';
import { SupportEngine } from './systems/SupportEngine.js';
import { SKILLS } from './data/skills.js';
import { EFFECTS } from './data/effects.js';
import { ITEMS } from './data/items.js';
import { Item } from './entities.js';
import { rollOnTable } from './utils/random.js';
import { getMonsterLootTable } from './data/tables.js';
import { MicroEngine } from './micro/MicroEngine.js';
import { MicroCombatManager } from './micro/MicroCombatManager.js';
import { MicroItemAIManager } from './managers/microItemAIManager.js';

import { StatusEffectsManager } from './managers/statusEffectsManager.js';
import { disarmWorkflow, armorBreakWorkflow } from './workflows.js';
import { PossessionAIManager } from './managers/possessionAIManager.js';
import { Ghost } from './entities.js';
import { TankerGhostAI, RangedGhostAI, SupporterGhostAI, CCGhostAI } from './ai.js';
import { EMBLEMS } from './data/emblems.js';
import { adjustMonsterStatsForAquarium } from './utils/aquariumUtils.js';
import DataRecorder from './managers/dataRecorder.js';
import GuidelineLoader from './managers/guidelineLoader.js';
import { AspirationManager } from './managers/aspirationManager.js';
import { MicroWorldWorker } from './micro/MicroWorldWorker.js';
import { CinematicManager } from './managers/cinematicManager.js';
import { ItemTracker } from './managers/itemTracker.js';
import { findEntitiesInRadius } from './utils/entityUtils.js';
import { LaneManager } from './managers/laneManager.js';
import { LaneRenderManager } from './managers/laneRenderManager.js';
import { LanePusherAI } from './ai/archetypes.js';
import { LaneAssignmentManager } from './managers/laneAssignmentManager.js';
import { FormationManager } from './managers/formationManager.js';
import { TooltipManager } from './managers/tooltipManager.js';
import { RLObserver } from './managers/index.js';

export class Game {
    constructor() {
        this.loader = new AssetLoader();
        this.gameState = { currentState: 'LOADING' };
    }

    start() {
        this.loader.loadImage('player', 'assets/player.png');
        this.loader.loadImage('monster', 'assets/monster.png');
        this.loader.loadImage('epic_monster', 'assets/epic_monster.png');
        // ë³‘ì¢…ë³„ ìš©ë³‘ ì´ë¯¸ì§€ë¥¼ ë¡œë“œí•œë‹¤
        this.loader.loadImage('warrior', 'assets/images/warrior.png');
        this.loader.loadImage('archer', 'assets/images/archer.png');
        this.loader.loadImage('healer', 'assets/images/healer.png');
        this.loader.loadImage('wizard', 'assets/images/wizard.png');
        this.loader.loadImage('summoner', 'assets/images/summoner.png');
        this.loader.loadImage('bard', 'assets/images/bard.png');
        // ë¶ˆì˜ ì‹  ì´ë¯¸ì§€ í‚¤ë¥¼ jobIdì™€ ë§žì¶° 'fire_god'ìœ¼ë¡œ ë¡œë“œí•œë‹¤
        this.loader.loadImage('fire_god', 'assets/images/fire-god.png');
        // ê¸°ì¡´ í˜¸í™˜ì„±ì„ ìœ„í•´ ê¸°ë³¸ mercenary í‚¤ë„ ì „ì‚¬ ì´ë¯¸ì§€ë¡œ ìœ ì§€
        this.loader.loadImage('mercenary', 'assets/images/warrior.png');
        this.loader.loadImage('floor', 'assets/floor.png');
        this.loader.loadImage('wall', 'assets/wall.png');
        this.loader.loadImage('gold', 'assets/gold.png');
        this.loader.loadImage('potion', 'assets/potion.png');
        this.loader.loadImage('sword', 'assets/images/shortsword.png');
        this.loader.loadWeaponImages();
        this.loader.loadImage('shield', 'assets/images/shield.png');
        this.loader.loadImage('bow', 'assets/images/bow.png');
        this.loader.loadImage('arrow', 'assets/images/arrow.png');
        this.loader.loadImage('leather_armor', 'assets/images/leatherarmor.png');
        this.loader.loadImage('plate-armor', 'assets/images/plate-armor.png');
        this.loader.loadImage('iron-helmet', 'assets/images/iron-helmet.png');
        this.loader.loadImage('iron-gauntlets', 'assets/images/iron-gauntlets.png');
        this.loader.loadImage('iron-boots', 'assets/images/iron-boots.png');
        this.loader.loadImage('violin-bow', 'assets/images/violin-bow.png');
        this.loader.loadImage('skeleton', 'assets/images/skeleton.png');
        this.loader.loadImage('pet-fox', 'assets/images/pet-fox.png');
        this.loader.loadImage('guardian-hymn-effect', 'assets/images/Guardian Hymn-effect.png');
        this.loader.loadImage('courage-hymn-effect', 'assets/images/Courage Hymn-effect.png');
        this.loader.loadImage('fire-ball', 'assets/images/fire-ball.png');
        this.loader.loadImage('ice-ball', 'assets/images/ice-ball-effect.png');
        this.loader.loadImage('strike-effect', 'assets/images/strike-effect.png');
        this.loader.loadImage('healing-effect', 'assets/images/healing-effect.png');
        this.loader.loadImage('purify-effect', 'assets/images/purify-effect.png');
        this.loader.loadImage('corpse', 'assets/images/corpse.png');
        this.loader.loadImage('parasite', 'assets/images/parasite.png');
        this.loader.loadImage('leech', 'assets/images/parasite.png');
        this.loader.loadImage('worm', 'assets/images/parasite.png');
        // ì›”ë“œë§µ íƒ€ì¼ ì´ë¯¸ì§€ ë¡œë“œ
        this.loader.loadImage('world-tile', 'assets/images/world-tile.png');
        this.loader.loadImage('sea-tile', 'assets/images/sea-tile.png');
        this.loader.loadImage('talisman1', 'assets/images/talisman-1.png');
        this.loader.loadImage('talisman2', 'assets/images/talisman-2.png');
        // íœ˜ìž¥ ì•„ì´í…œ ì´ë¯¸ì§€ ë¡œë“œ
        this.loader.loadEmblemImages();
        // ì‹œê° íš¨ê³¼ ì´ë¯¸ì§€ ë¡œë“œ
        this.loader.loadVfxImages();

        this.loader.onReady(assets => this.init(assets));
    }

    init(assets) {
        this.assets = assets;
        // ì„¤ì •ì— ë”°ë¼ WebGL ë ˆì´ì–´ë¥¼ í™œì„±í™”í•œë‹¤
        this.layerManager = new LayerManager(SETTINGS.ENABLE_WEBGL_RENDERER);
        const canvas = this.layerManager.layers.mapBase;

        // === 1. ëª¨ë“  ë§¤ë‹ˆì € ë° ì‹œìŠ¤í…œ ìƒì„± ===
        this.eventManager = new EventManager();
        this.tooltipManager = new TooltipManager();
        this.entityManager = new EntityManager(this.eventManager);
        // InputHandlerë¥¼ ìƒì„±í•  ë•Œ game ê°ì²´(this)ë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤.
        this.inputHandler = new InputHandler(this);
        this.combatLogManager = new CombatLogManager(this.eventManager);
        
        this.statusEffectsManager = new StatusEffectsManager(this.eventManager);
        this.tagManager = new TagManager();
        this.combatCalculator = new CombatCalculator(this.eventManager, this.tagManager);
        // Player begins in the Aquarium map for feature testing
        this.mapManager = new AquariumMapManager();
        const mapPixelWidth = this.mapManager.width * this.mapManager.tileSize;
        const mapPixelHeight = this.mapManager.height * this.mapManager.tileSize;
        const laneCenters = this.mapManager.getLaneCenters ? this.mapManager.getLaneCenters() : null;
        this.laneManager = new LaneManager(mapPixelWidth, mapPixelHeight, laneCenters);
        this.laneRenderManager = new LaneRenderManager(this.laneManager, SETTINGS.ENABLE_AQUARIUM_LANES);
        const formationSpacing = this.mapManager.tileSize * 2.5;
        const formationAngle = -Math.PI / 4; // align grid with battlefield orientation
        this.formationManager = new FormationManager(5, 5, formationSpacing, 'LEFT', formationAngle);
        this.eventManager.subscribe('formation_assign_request', d => {
            if (d.squadId) {
                const squad = this.squadManager.getSquad(d.squadId);
                if (squad) {
                    squad.members.forEach(id => this.formationManager.assign(d.slotIndex, id));
                }
            } else {
                this.formationManager.assign(d.slotIndex, d.entityId);
            }
            this.uiManager?.createSquadManagementUI();
        });
        this.saveLoadManager = new SaveLoadManager();
        this.turnManager = new TurnManager();
        this.narrativeManager = new NarrativeManager();
        this.supportEngine = new SupportEngine();
        this.factory = new CharacterFactory(assets, this);
        this.inventoryManager = new InventoryManager({
            eventManager: this.eventManager,
            entityManager: this.entityManager,
        });
        // ì›”ë“œë§µ ë¡œì§ì„ ë‹´ë‹¹í•˜ëŠ” ì—”ì§„
        this.worldEngine = new WorldEngine(this, assets);

        // --- ë§¤ë‹ˆì € ìƒì„± ë¶€ë¶„ ìˆ˜ì • ---
        this.managers = {};
        // ItemManagerë¥¼ ë¨¼ì € ìƒì„±í•©ë‹ˆë‹¤.
        this.itemTracker = new ItemTracker();
        this.itemManager = new Managers.ItemManager(0, this.mapManager, assets, this.itemTracker);
        this.managers.ItemManager = this.itemManager;

        // VFXManagerëŠ” ItemManagerì™€ EventManagerê°€ ëª¨ë‘ í•„ìš”í•©ë‹ˆë‹¤.
        this.managers.VFXManager = new Managers.VFXManager(this.eventManager, this.itemManager);

        const otherManagerNames = Object.keys(Managers).filter(
            name =>
                name !== 'VFXManager' &&
                name !== 'ItemManager' &&
                name !== 'AuraManager' &&
                name !== 'ItemAIManager' &&
                name !== 'EffectManager' &&
                name !== 'SkillManager' &&
                name !== 'ProjectileManager' &&
                name !== 'SquadManager' &&
                name !== 'DataRecorder'
        );
        for (const managerName of otherManagerNames) {
            if (managerName === 'UIManager') {
                this.managers[managerName] = new Managers.UIManager(
                    this.eventManager,
                    (id) => this.entityManager?.getEntityById(id),
                    this.tooltipManager
                );
            } else {
                this.managers[managerName] = new Managers[managerName](this.eventManager, assets, this.factory);
            }
        }

        this.managers.EffectManager = new Managers.EffectManager(
            this.eventManager,
            this.managers.VFXManager
        );

        this.monsterManager = this.managers.MonsterManager;
        this.mercenaryManager = this.managers.MercenaryManager;
        this.itemManager = this.managers.ItemManager;
        this.equipmentManager = this.managers.EquipmentManager;
        this.uiManager = this.managers.UIManager;
        this.vfxManager = this.managers.VFXManager;
        this.vfxManager.game = this;
        this.soundManager = this.managers.SoundManager;
        this.bgmManager = this.managers.BgmManager;
        this.effectManager = this.managers.EffectManager;
        this.auraManager = new Managers.AuraManager(this.effectManager, this.eventManager, this.vfxManager);
        this.microItemAIManager = new Managers.MicroItemAIManager();
        this.microEngine = new MicroEngine(this.eventManager);
        this.microCombatManager = new MicroCombatManager(this.eventManager);
        this.synergyManager = new Managers.SynergyManager(this.eventManager);
        this.uiManager.setSynergyManager(this.synergyManager);
        this.speechBubbleManager = this.managers.SpeechBubbleManager;
        this.equipmentRenderManager = this.managers.EquipmentRenderManager;
        this.mercenaryManager.equipmentRenderManager = this.equipmentRenderManager;
        this.traitManager = this.managers.TraitManager;
        this.mercenaryManager.setTraitManager(this.traitManager);
        this.monsterManager.setTraitManager(this.traitManager);
        this.parasiteManager = this.managers.ParasiteManager;
        this.microWorld = new MicroWorldWorker();

        // ë§¤ë‹ˆì € ê°„ ì˜ì¡´ì„± ì—°ê²°
        this.equipmentManager.setTagManager(this.tagManager);

        this.itemFactory = new ItemFactory(assets);
                // ê²Œìž„ ì‹œìž‘ ì‹œ ë¬´ê¸° ì•„ì´í…œë“¤ì„ í•œ ê°œì”© ê³ ìš© ì¸ë²¤í† ë¦¬ì— ë°°ì¹˜í•©ë‹ˆë‹¤.
        const weaponIds = Object.keys(ITEMS).filter(id => ITEMS[id].type === 'weapon');
        weaponIds.forEach(id => {
            const weapon = this.itemFactory.create(id, 0, 0, this.mapManager.tileSize);
            if (weapon) this.inventoryManager.getSharedInventory().push(weapon);
        });
        this.pathfindingManager = new PathfindingManager(this.mapManager);
        this.motionManager = new Managers.MotionManager(this.mapManager, this.pathfindingManager);
        this.knockbackEngine = new KnockbackEngine(this.motionManager, this.vfxManager);
        this.projectileManager = new Managers.ProjectileManager(
            this.eventManager,
            assets,
            this.vfxManager,
            this.knockbackEngine
        );
        this.managers.ProjectileManager = this.projectileManager;
        this.itemAIManager = new Managers.ItemAIManager(
            this.eventManager,
            this.projectileManager,
            this.vfxManager
        );
        this.itemAIManager.setEffectManager(this.effectManager);
        this.movementManager = new MovementManager(this.mapManager);
        this.fogManager = new FogManager(this.mapManager.width, this.mapManager.height);
        this.particleDecoratorManager = new Managers.ParticleDecoratorManager();
        this.particleDecoratorManager.setManagers(this.vfxManager, this.mapManager);
        this.particleDecoratorManager.init();
        this.effectIconManager = new Managers.EffectIconManager(this.eventManager, assets);
        // UIManagerê°€ mercenaryManagerì— ì ‘ê·¼í•  ìˆ˜ ìžˆë„ë¡ ì„¤ì •
        this.uiManager.mercenaryManager = this.mercenaryManager;
        this.mercenaryManager.setUIManager(this.uiManager);
        this.uiManager.particleDecoratorManager = this.particleDecoratorManager;
        this.uiManager.vfxManager = this.vfxManager;
        this.uiManager.eventManager = this.eventManager;
        // UIManagerê°€ Game ì¸ìŠ¤í„´ìŠ¤ì— ì ‘ê·¼í•  ìˆ˜ ìžˆë„ë¡ ì°¸ì¡°ë¥¼ ì „ë‹¬
        this.uiManager.game = this;
        this.uiManager.getSharedInventory = () => this.inventoryManager.getSharedInventory();
        this.uiManager.formationManager = this.formationManager;
        this.squadManager = new Managers.SquadManager(this.eventManager, this.mercenaryManager);
        this.uiManager.squadManager = this.squadManager;
        this.uiManager.createSquadManagementUI?.();
        this.laneAssignmentManager = new LaneAssignmentManager({
            laneManager: this.laneManager,
            squadManager: this.squadManager,
            eventManager: this.eventManager
        });
        this.metaAIManager = new MetaAIManager(this.eventManager, this.squadManager);
        this.monsterManager.setMetaAIManager(this.metaAIManager);
        if (SETTINGS.ENABLE_REPUTATION_SYSTEM) {
            this.reputationManager = new ReputationManager(this.eventManager);
            this.reputationManager.mercenaryManager = this.mercenaryManager;
            this.reputationManager.mbtiEngine = this.metaAIManager.mbtiEngine;
            this.reputationManager.loadReputationModel();
        } else {
            this.reputationManager = null;
        }
        this.cinematicManager = new CinematicManager(this);
        this.dataRecorder = new DataRecorder(this);
        this.dataRecorder.init();
        this.rlObserver = new RLObserver(this.eventManager, this.mapManager);
        this.rlObserver.init();
        this.guidelineLoader = new GuidelineLoader(SETTINGS.GUIDELINE_REPO_URL);
        this.guidelineLoader.load();
        if (SETTINGS.ENABLE_POSSESSION_SYSTEM) {
            this.possessionAIManager = new PossessionAIManager(this.eventManager);
        } else {
            this.possessionAIManager = null;
        }
        this.itemFactory.emblems = EMBLEMS;

        this.skillManager = new Managers.SkillManager(
            this.eventManager,
            this.vfxManager,
            this.projectileManager,
            this.motionManager,
            this.factory,
            this.metaAIManager,
            this.knockbackEngine
        );
        this.managers.SkillManager = this.skillManager;

        const ghostAIs = {
            tanker: new TankerGhostAI(),
            ranged: new RangedGhostAI(),
            supporter: new SupporterGhostAI(),
            cc: new CCGhostAI()
        };
        if (this.possessionAIManager) {
            const ghostTypes = Object.keys(ghostAIs);
            const numGhosts = Math.floor(Math.random() * 3) + 1;
            for (let i = 0; i < numGhosts; i++) {
                const randomType = ghostTypes[Math.floor(Math.random() * ghostTypes.length)];
                this.possessionAIManager.addGhost(new Ghost(randomType, ghostAIs[randomType]));
            }
        }
        this.petManager = new Managers.PetManager(this.eventManager, this.factory, this.metaAIManager, this.auraManager, this.vfxManager);
        this.managers.PetManager = this.petManager;
        this.skillManager.setManagers(this.effectManager, this.factory, this.metaAIManager, this.monsterManager);
        this.aquariumManager = new AquariumManager(
            this.eventManager,
            this.monsterManager,
            this.itemManager,
            this.mapManager,
            this.factory,
            this.itemFactory,
            this.vfxManager,
            this.traitManager
        );
        this.aquariumInspector = new AquariumInspector(this.aquariumManager);

        for (let i = 0; i < 20; i++) {
            const pos = this.mapManager.getRandomFloorPosition();
            if (pos) {
                const rand = Math.random();
                let itemName = 'potion';
                if (rand < 0.6) itemName = 'gold';
                else if (rand < 0.7) itemName = 'fox_charm';
                const item = this.itemFactory.create(itemName, pos.x, pos.y, this.mapManager.tileSize);
                if (item) this.itemManager.addItem(item);
            }
        }

        // === ê·¸ë£¹ ìƒì„± ===
        this.playerGroup = this.metaAIManager.createGroup('player_party', STRATEGY.AGGRESSIVE);
        // í”Œë ˆì´ì–´ëŠ” ì§ì ‘ ì¡°ì¢…í•˜ë¯€ë¡œ AIë¥¼ ë¹„í™œì„±í™”í•˜ì§€ë§Œ ìš©ë³‘ì€ ê³„ì† í–‰ë™í•˜ê²Œ ë‘¡ë‹ˆë‹¤.
        this.monsterGroup = this.metaAIManager.createGroup('dungeon_monsters', STRATEGY.AGGRESSIVE);

        // === ëª¬ìŠ¤í„° ë¶€ëŒ€ ìƒì„± ===
        const enemyFormationManager = new FormationManager(5, 5, formationSpacing, 'RIGHT', formationAngle);
        const enemyFormationOrigin = {
            x: (this.mapManager.width - 8) * this.mapManager.tileSize,
            y: (this.mapManager.height / 2) * this.mapManager.tileSize,
        };
        const monsterSquad = [];
        const monsterCount = 15;
        for (let i = 0; i < monsterCount; i++) {
            const monster = this.factory.create('monster', {
                x: 0,
                y: 0,
                tileSize: this.mapManager.tileSize,
                groupId: this.monsterGroup.id,
                image: assets.monster,
            });
            monster.equipmentRenderManager = this.equipmentRenderManager;

            const weaponIds = ['short_sword','long_bow','axe','mace','staff','spear','scythe','whip','dagger','estoc'];
            const wId = weaponIds[Math.floor(Math.random() * weaponIds.length)];
            const weapon = this.itemFactory.create(wId, 0, 0, this.mapManager.tileSize);
            if (weapon) this.equipmentManager.equip(monster, weapon, null);

            const armorParts = ['iron_helmet','iron_gauntlets','iron_boots','leather_armor'];
            armorParts.forEach(p => {
                const item = this.itemFactory.create(p, 0, 0, this.mapManager.tileSize);
                if (item) this.equipmentManager.equip(monster, item, null);
            });

            const consumable = this.itemFactory.create('potion', 0, 0, this.mapManager.tileSize);
            if (consumable) monster.consumables.push(consumable);

            this.monsterManager.addMonster(monster);
            monsterSquad.push(monster);
        }
        const monsterEntityMap = {};
        monsterSquad.forEach(m => { monsterEntityMap[m.id] = m; });
        monsterSquad.forEach((monster, idx) => {
            if (idx < 25) {
                enemyFormationManager.assign(idx, monster.id);
            }
        });
        enemyFormationManager.apply(enemyFormationOrigin, monsterEntityMap);

        // === 2. í”Œë ˆì´ì–´ ìƒì„± ===
        let startPos;
        startPos = { x: this.mapManager.tileSize * 8, y: (this.mapManager.height * this.mapManager.tileSize) / 2 };
        const player = this.factory.create('player', {
            x: startPos.x,
            y: startPos.y,
            tileSize: this.mapManager.tileSize,
            groupId: this.playerGroup.id,
            image: assets.player,
            // ì´ˆë°˜ ë‚œì´ë„ë¥¼ ë§žì¶”ê¸° ìœ„í•´ ì´ë™ ì†ë„ë¥¼ ë‚®ì¶˜ë‹¤
            baseStats: { strength: 5, agility: 5, endurance: 15, movement: 4 }
        });
        player.ai = null; // disable any automatic skills for the player
        player.equipmentRenderManager = this.equipmentRenderManager;

        // ì´ˆê¸° ìž¥ë¹„ ì„¸íŒ…
        const pHelmet = this.itemFactory.create('iron_helmet', 0, 0, this.mapManager.tileSize);
        const pGloves = this.itemFactory.create('iron_gauntlets', 0, 0, this.mapManager.tileSize);
        const pBoots = this.itemFactory.create('iron_boots', 0, 0, this.mapManager.tileSize);
        const pArmor = this.itemFactory.create('leather_armor', 0, 0, this.mapManager.tileSize);
        if (pHelmet) this.equipmentManager.equip(player, pHelmet, null);
        if (pGloves) this.equipmentManager.equip(player, pGloves, null);
        if (pBoots) this.equipmentManager.equip(player, pBoots, null);
        if (pArmor) this.equipmentManager.equip(player, pArmor, null);
        this.gameState = {
            currentState: 'WORLD',
            player,
            inventory: this.inventoryManager.getSharedInventory(),
            gold: 1000,
            statPoints: 5,
            camera: { x: 0, y: 0 },
            isGameOver: false,
            zoomLevel: SETTINGS.DEFAULT_ZOOM,
            isPaused: false
        };
        this.cameraDrag = {
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            cameraStart: { x: 0, y: 0 },
            followPlayer: true
        };
        this.playerGroup.addMember(player);
        // Game ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ì§ì ‘ í”Œë ˆì´ì–´ì— ì ‘ê·¼í•  ìˆ˜ ìžˆë„ë¡ ì°¸ì¡°ë¥¼ ì €ìž¥í•©ë‹ˆë‹¤.
        this.player = player;
        // ì›”ë“œ ì—”ì§„ì—ì„œë„ ë™ì¼í•œ í”Œë ˆì´ì–´ ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ì„¤ì •
        this.worldEngine.setPlayer(player);

        // ì´ˆê¸° ì•„ì´í…œ ë°°ì¹˜
        if (this.mapManager.name !== 'aquarium') {
            const potion = this.itemFactory.create(
                                    'potion',
                                    player.x + this.mapManager.tileSize,
                                    player.y,
                                    this.mapManager.tileSize);
            const dagger = this.itemFactory.create('short_sword',
                                    player.x - this.mapManager.tileSize,
                                    player.y,
                                    this.mapManager.tileSize);
            const bow = this.itemFactory.create('long_bow',
                                    player.x,
                                    player.y + this.mapManager.tileSize,
                                    this.mapManager.tileSize);
            const violinBow = this.itemFactory.create('violin_bow',
                                    player.x + this.mapManager.tileSize,
                                    player.y - this.mapManager.tileSize,
                                    this.mapManager.tileSize);
            const plateArmor = this.itemFactory.create('plate_armor',
                                    player.x + this.mapManager.tileSize * 2,
                                    player.y - this.mapManager.tileSize,
                                    this.mapManager.tileSize);
            const foxEgg = this.itemFactory.create('pet_fox',
                                    player.x - this.mapManager.tileSize * 2,
                                    player.y,
                                    this.mapManager.tileSize);
            const foxCharm = this.itemFactory.create('fox_charm',
                                    player.x,
                                    player.y - this.mapManager.tileSize * 2,
                                    this.mapManager.tileSize);
            // --- í…ŒìŠ¤íŠ¸ìš© íœ˜ìž¥ ì•„ì´í…œ 4ì¢… ë°°ì¹˜ ---
            const emblemGuardian = this.itemFactory.create('emblem_guardian', player.x + 64, player.y + 64, this.mapManager.tileSize);
            const emblemDestroyer = this.itemFactory.create('emblem_destroyer', player.x - 64, player.y + 64, this.mapManager.tileSize);
            const emblemDevotion = this.itemFactory.create('emblem_devotion', player.x + 64, player.y - 64, this.mapManager.tileSize);
            const emblemConductor = this.itemFactory.create('emblem_conductor', player.x - 64, player.y - 64, this.mapManager.tileSize);
            this.itemManager.addItem(potion);
            if (dagger) this.itemManager.addItem(dagger);
            if (bow) this.itemManager.addItem(bow);
            if (violinBow) this.itemManager.addItem(violinBow);
            if (plateArmor) this.itemManager.addItem(plateArmor);
            if (foxEgg) this.itemManager.addItem(foxEgg);
            if (foxCharm) this.itemManager.addItem(foxCharm);
            if(emblemGuardian) this.itemManager.addItem(emblemGuardian);
            if(emblemDestroyer) this.itemManager.addItem(emblemDestroyer);
            if(emblemDevotion) this.itemManager.addItem(emblemDevotion);
            if(emblemConductor) this.itemManager.addItem(emblemConductor);
        }

        // === 3. ëª¬ìŠ¤í„° ìƒì„± ===
        // ê¸°ì¡´ ë¬´ìž‘ìœ„ ìŠ¤í° ë¡œì§ì„ ì œê±°í•˜ê³  formationManagerë¥¼ í†µí•´ ì¼ê´„ ë°°ì¹˜í•©ë‹ˆë‹¤.

        if (SETTINGS.ENABLE_AQUARIUM_LANES) {
            // --- 3-Lane ëª¨ë“œ ì„¤ì • ë¡œì§ ---
            const friendlySquads = this.squadManager.getSquads();
            const lanes = ['TOP', 'MID', 'BOTTOM'];
            Object.values(friendlySquads).forEach((squad, index) => {
                const lane = lanes[index];
                if (!lane) return;
                squad.name = lane;
                squad.members.forEach(mercId => {
                    const merc = this.entityManager.getEntityById(mercId);
                    if (merc) {
                        merc.team = 'LEFT';
                        merc.lane = lane;
                        merc.ai = new LanePusherAI();
                        merc.currentWaypointIndex = 0;
                    }
                });
            });

            const allMonsters = this.monsterManager.getMonsters();
            const monstersPerLane = Math.floor(allMonsters.length / 3);
            allMonsters.forEach((monster, idx) => {
                let lane = 'MID';
                if (idx < monstersPerLane) lane = 'TOP';
                else if (idx < monstersPerLane * 2) lane = 'BOTTOM';

                monster.team = 'RIGHT';
                monster.lane = lane;
                monster.ai = new LanePusherAI();
                monster.currentWaypointIndex = 0;
                const startWaypoint = this.laneManager.getNextWaypoint(monster);
                if (startWaypoint) {
                    monster.x = startWaypoint.x;
                    monster.y = startWaypoint.y;
                }
            });
        }

        this.entityManager.init(this.gameState.player, this.mercenaryManager.mercenaries, this.monsterManager.monsters);
        // Apply initial formation for player party
        const origin = { x: this.gameState.player.x, y: this.gameState.player.y };
        const entityMap = { [player.id]: this.gameState.player };
        this.mercenaryManager.mercenaries.forEach(m => { entityMap[m.id] = m; });
        this.formationManager.assign(12, player.id);
        this.mercenaryManager.mercenaries.forEach((m, idx) => {
            const slotIndex = [6, 7, 8, 11, 13][idx] || idx;
            this.formationManager.assign(slotIndex, m.id);
        });
        this.formationManager.apply(origin, entityMap);
        this.equipmentManager.entityManager = this.entityManager;
        this.aspirationManager = new AspirationManager(this.eventManager, this.microWorld, this.effectManager, this.vfxManager, this.entityManager);

        // === 4. ìš©ë³‘ ê³ ìš© ë¡œì§ ===
        const hireBtn = document.getElementById('hire-mercenary');
        if (hireBtn) {
            hireBtn.onclick = () => {
                if (this.gameState.gold >= 50) {
                    this.gameState.gold -= 50;
                    const newMerc = this.mercenaryManager.hireMercenary(
                        'warrior',
                        this.gameState.player.x,
                        this.gameState.player.y,
                        this.mapManager.tileSize,
                        'player_party'
                    );

                    if (newMerc) {
                        this.laneAssignmentManager.assignMercenaryToLane(newMerc);
                        this.entityManager.addEntity(newMerc);
                        this.playerGroup.addMember(newMerc);
                        this.eventManager.publish('mercenary_hired', { mercenary: newMerc });
                    }
                } else {
                    this.eventManager.publish('log', { message: `ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.` });
                }
            };
        }

        const archerBtn = document.getElementById('hire-archer');
        if (archerBtn) {
            archerBtn.onclick = () => {
                if (this.gameState.gold >= 50) {
                    this.gameState.gold -= 50;
                    const newMerc = this.mercenaryManager.hireMercenary(
                        'archer',
                        this.gameState.player.x,
                        this.gameState.player.y,
                        this.mapManager.tileSize,
                        'player_party'
                    );

                    if (newMerc) {
                        this.laneAssignmentManager.assignMercenaryToLane(newMerc);
                        this.entityManager.addEntity(newMerc);
                        this.playerGroup.addMember(newMerc);
                        this.eventManager.publish('mercenary_hired', { mercenary: newMerc });
                    }
                } else {
                    this.eventManager.publish('log', { message: `ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.` });
                }
            };
        }

        const healerBtn = document.getElementById('hire-healer');
        if (healerBtn) {
            healerBtn.onclick = () => {
                if (this.gameState.gold >= 50) {
                    this.gameState.gold -= 50;
                    const newMerc = this.mercenaryManager.hireMercenary(
                        'healer',
                        this.gameState.player.x,
                        this.gameState.player.y,
                        this.mapManager.tileSize,
                        'player_party'
                    );

                    if (newMerc) {
                        this.laneAssignmentManager.assignMercenaryToLane(newMerc);
                        this.entityManager.addEntity(newMerc);
                        this.playerGroup.addMember(newMerc);
                        this.eventManager.publish('mercenary_hired', { mercenary: newMerc });
                    }
                } else {
                    this.eventManager.publish('log', { message: `ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.` });
                }
            };
        }

        const wizardBtn = document.getElementById('hire-wizard');
        if (wizardBtn) {
            wizardBtn.onclick = () => {
                if (this.gameState.gold >= 50) {
                    this.gameState.gold -= 50;
                    const newMerc = this.mercenaryManager.hireMercenary(
                        'wizard',
                        this.gameState.player.x,
                        this.gameState.player.y,
                        this.mapManager.tileSize,
                        'player_party'
                    );

                    if (newMerc) {
                        this.laneAssignmentManager.assignMercenaryToLane(newMerc);
                        this.entityManager.addEntity(newMerc);
                        this.playerGroup.addMember(newMerc);
                        this.eventManager.publish('mercenary_hired', { mercenary: newMerc });
                    }
                } else {
                    this.eventManager.publish('log', { message: `ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.` });
                }
            };
        }

        const bardBtn = document.getElementById('hire-bard');
        if (bardBtn) {
            bardBtn.onclick = () => {
                if (this.gameState.gold >= 50) {
                    this.gameState.gold -= 50;
                    const newMerc = this.mercenaryManager.hireMercenary(
                        'bard',
                        this.gameState.player.x,
                        this.gameState.player.y,
                        this.mapManager.tileSize,
                        'player_party'
                    );

                    if (newMerc) {
                        this.laneAssignmentManager.assignMercenaryToLane(newMerc);
                        this.entityManager.addEntity(newMerc);
                        this.playerGroup.addMember(newMerc);
                        this.eventManager.publish('mercenary_hired', { mercenary: newMerc });
                    }
                } else {
                    this.eventManager.publish('log', { message: `ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.` });
                }
            };
        }

        const summonerBtn = document.getElementById('hire-summoner');
        if (summonerBtn) {
            summonerBtn.onclick = () => {
                if (this.gameState.gold >= 50) {
                    this.gameState.gold -= 50;
                    const newMerc = this.mercenaryManager.hireMercenary(
                        'summoner',
                        this.gameState.player.x,
                        this.gameState.player.y,
                        this.mapManager.tileSize,
                        'player_party'
                    );

                    if (newMerc) {
                        this.laneAssignmentManager.assignMercenaryToLane(newMerc);
                        this.entityManager.addEntity(newMerc);
                        this.playerGroup.addMember(newMerc);
                        this.eventManager.publish('mercenary_hired', { mercenary: newMerc });
                    }
                } else {
                    this.eventManager.publish('log', { message: `ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.` });
                }
            };
        }

        const fireGodBtn = document.getElementById('hire-fire-god');
        if (fireGodBtn) {
            fireGodBtn.onclick = () => {
                if (this.gameState.gold >= 100) {
                    this.gameState.gold -= 100;
                    const newMerc = this.mercenaryManager.hireMercenary(
                        'fire_god',
                        this.gameState.player.x,
                        this.gameState.player.y,
                        this.mapManager.tileSize,
                        'player_party'
                    );

                    if (newMerc) {
                        this.laneAssignmentManager.assignMercenaryToLane(newMerc);
                        this.entityManager.addEntity(newMerc);
                        this.playerGroup.addMember(newMerc);
                        this.eventManager.publish('mercenary_hired', { mercenary: newMerc });
                    }
                } else {
                    this.eventManager.publish('log', { message: `ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.` });
                }
            };
        }

        const saveBtn = document.getElementById('save-game-btn');
        if (saveBtn) {
            saveBtn.onclick = () => {
                const saveData = this.saveLoadManager.gatherSaveData(this.gameState, this.monsterManager, this.mercenaryManager);
                console.log("--- GAME STATE SAVED (SNAPSHOT) ---");
                console.log(saveData);
                this.eventManager.publish('log', { message: 'ê²Œìž„ ìƒíƒœ ìŠ¤ëƒ…ìƒ·ì´ ì½˜ì†”ì— ì €ìž¥ë˜ì—ˆìŠµë‹ˆë‹¤.' });
            };
        }

        const autoBtn = document.getElementById('toggle-autobattle-btn');
        if (autoBtn) {
            autoBtn.onclick = () => {
                const player = this.gameState.player;
                player.autoBattle = !player.autoBattle;
                if (typeof player.updateAI === 'function') player.updateAI();
                autoBtn.textContent = `ìžë™ ì „íˆ¬: ${player.autoBattle ? 'ON' : 'OFF'}`;
            };
        }

        // === ë©”ë‰´ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ìˆ˜ì • ===
        const playerInfoBtn = document.querySelector('.menu-btn[data-panel-id="character-sheet-panel"]');
        if (playerInfoBtn) {
            playerInfoBtn.onclick = () => {
                this.uiManager.displayCharacterSheet(this.gameState.player);
                this.gameState.isPaused = true;
            };
        }
        document.querySelectorAll('.menu-btn').forEach(button => {
            if (button.dataset.panelId !== 'character-sheet-panel') {
                button.onclick = () => {
                    const panelId = button.dataset.panelId;
                    this.uiManager.showPanel(panelId);
                    this.gameState.isPaused = true;
                };
            }
        });

        this.setupEventListeners(assets, canvas);

        this.gameLoop = new GameLoop(this.update, this.render);
        this.gameLoop.start();
    }

    setupEventListeners(assets, canvas) {
        const { eventManager, combatCalculator, monsterManager, mercenaryManager, mapManager, metaAIManager, pathfindingManager } = this;
        const gameState = this.gameState;

        // ì›”ë“œë§µê³¼ ì „íˆ¬ ìƒíƒœ ì „í™˜ ì´ë²¤íŠ¸ ì²˜ë¦¬
        eventManager.subscribe('start_combat', (data) => {
            console.log(`ì „íˆ¬ ì¤€ë¹„! ìƒëŒ€ ë¶€ëŒ€ ê·œëª¨: ${data.monsterParty.troopSize}`);
            gameState.currentState = 'FORMATION_SETUP';
            this.pendingMonsterParty = data.monsterParty;
            this.uiManager.showPanel('squad-management-ui');
            this.worldEngine.monsters.forEach(m => m.isActive = false);
        });

        eventManager.subscribe('formation_confirmed', () => {
            const origin = { x: gameState.player.x, y: gameState.player.y };
            const entityMap = { [gameState.player.id]: gameState.player };
            this.mercenaryManager.mercenaries.forEach(m => { entityMap[m.id] = m; });
            this.formationManager.apply(origin, entityMap);
            gameState.currentState = 'COMBAT';
        });

        eventManager.subscribe('end_combat', (result) => {
            console.log(`ì „íˆ¬ ì¢…ë£Œ! ê²°ê³¼: ${result.outcome}`);
            gameState.currentState = 'WORLD';
            if (result.outcome === 'victory') {
                this.worldEngine.monsters = this.worldEngine.monsters.filter(m => m.isActive === false);
            }
            this.worldEngine.monsters.forEach(m => m.isActive = true);
        });

        // ê³µê²© ì´ë²¤íŠ¸ ì²˜ë¦¬
        eventManager.subscribe('entity_attack', (data) => {
            this.microCombatManager.resolveAttack(data.attacker, data.defender);
            combatCalculator.handleAttack(data, { knockbackEngine: this.knockbackEngine });

            const { attacker, defender, skill } = data;
            if (!skill || !skill.projectile) {
                const img = assets['strike-effect'];
                if (img) {
                    this.vfxManager.addSpriteEffect(
                        img,
                        defender.x + defender.width / 2,
                        defender.y + defender.height / 2,
                        {
                            width: defender.width,
                            height: defender.height,
                            blendMode: 'screen'
                        }
                    );
                    this.vfxManager.addParticleBurst(
                        defender.x + defender.width / 2,
                        defender.y + defender.height / 2,
                        { color: 'rgba(200,0,0,0.9)', count: 12 }
                    );
                }
            }
        });

        // 'charge_hit' ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        eventManager.subscribe('charge_hit', (data) => {
            const { attacker, defender } = data;
            if (!defender || defender.hp <= 0) return;

            // 1. í”¼í•´ë¥¼ ìž…íž™ë‹ˆë‹¤.
            this.handleAttack(attacker, defender, { name: 'ëŒì§„' });
            
            // 2. ì—ì–´ë³¸ íš¨ê³¼ë¥¼ ì ìš©í•©ë‹ˆë‹¤.
            this.effectManager.addEffect(defender, 'airborne');

            this.eventManager.publish('log', { message: `\uD83D\uDCA8 ${defender.constructor.name}ë¥¼ ê³µì¤‘ì— ë„ì› ìŠµë‹ˆë‹¤!`, color: 'lightblue' });
        });

        // ê¸°ì¡´ì˜ knockback_request ì´ë²¤íŠ¸ëŠ” KnockbackEngineìœ¼ë¡œ ëŒ€ì²´ë˜ì—ˆìŠµë‹ˆë‹¤.

        // í”¼í•´ëŸ‰ ê³„ì‚° ì™„ë£Œ ì´ë²¤íŠ¸ë¥¼ ë°›ì•„ ì‹¤ì œ í”¼í•´ ì ìš©
        eventManager.subscribe('damage_calculated', (data) => {
            data.defender.takeDamage(data.damage);
            eventManager.publish('entity_damaged', { attacker: data.attacker, defender: data.defender, damage: data.damage });
            if (data.defender.hp <= 0) {
                eventManager.publish('entity_death', { attacker: data.attacker, victim: data.defender });
            }
        });

        eventManager.subscribe('entity_damaged', (data) => {
            this.vfxManager.flashEntity(data.defender);

            // ìˆ˜ë©´ ìƒíƒœì¸ì§€ í™•ì¸
            const sleepEffect = data.defender.effects.find(e => e.id === 'sleep');
            if (sleepEffect) {
                const hitsToWake = sleepEffect.wakeUpOnHit || 1;
                sleepEffect.hitsTaken = (sleepEffect.hitsTaken || 0) + 1;

                if (sleepEffect.hitsTaken >= hitsToWake) {
                    this.effectManager.removeEffect(data.defender, sleepEffect);
                    this.eventManager.publish('log', { message: `\uD83D\uDCA4 ${data.defender.constructor.name}\uC774(ê°€) ê³µê²©ì„ ë°›ê³  ê¹¨ì–´ë‚¬ìŠµë‹ˆë‹¤!`, color: 'yellow' });
                }
            }
        });

        // í‰íŒ ì‹œìŠ¤í…œì„ ìœ„í•œ ëª¬ìŠ¤í„° ì²˜ì¹˜ ì´ë²¤íŠ¸
        eventManager.subscribe('monster_defeated', (data) => {
            if (!this.reputationManager) return;
            const action = {
                type: 'combat',
                outcome: 'victory',
                enemy: data.monster.type
            };
            this.reputationManager.handleGameEvent(action);
        });

        // ì£½ìŒ ì´ë²¤íŠ¸ê°€ ë°œìƒí•˜ë©´ ê²½í—˜ì¹˜ íšë“ ë° ì• ë‹ˆë©”ì´ì…˜ì„ ì‹œìž‘
        eventManager.subscribe('entity_death', (data) => {
            const { attacker, victim } = data;

            victim.isDying = true;
            this.vfxManager.addDeathAnimation(victim, 'explode');

            eventManager.publish('log', { message: `${victim.constructor.name}ê°€ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤.`, color: 'red' });

            if (victim.unitType === 'monster') {
                this.eventManager.publish('monster_defeated', { monster: victim, attacker });
                const dropPool = [];
                if (victim.consumables) dropPool.push(...victim.consumables);
                if (victim.equipment) {
                    for (const slot in victim.equipment) {
                        const it = victim.equipment[slot];
                        if (it) dropPool.push(it);
                    }
                }
                const dropCount = Math.min(dropPool.length, Math.floor(Math.random() * 6));
                for (let i = 0; i < dropCount; i++) {
                    const idx = Math.floor(Math.random() * dropPool.length);
                    const item = dropPool.splice(idx, 1)[0];
                    const startPos = { x: victim.x, y: victim.y };
                    const endPos = this.findRandomEmptyAdjacentTile(victim.x, victim.y) || startPos;
                    item.x = endPos.x;
                    item.y = endPos.y;
                    this.itemManager.addItem(item);
                    this.vfxManager.addItemPopAnimation(item, startPos, endPos);
                }
            }

            if (!victim.isFriendly && (attacker.isPlayer || attacker.isFriendly)) {
                if (attacker.isPlayer) {
                    // í”Œë ˆì´ì–´ê°€ ì§ì ‘ ì²˜ì¹˜í•œ ê²½ìš° ì „ì²´ ê²½í—˜ì¹˜ ì§€ê¸‰
                    eventManager.publish('exp_gained', { player: attacker, exp: victim.expValue });
                } else if (attacker.isFriendly) {
                    // ìš©ë³‘ì´ ì²˜ì¹˜í•œ ê²½ìš° ìš©ë³‘ê³¼ í”Œë ˆì´ì–´ê°€ ê²½í—˜ì¹˜ë¥¼ ì ˆë°˜ì”© ë‚˜ëˆ”
                    const sharedExp = victim.expValue / 2;
                    eventManager.publish('exp_gained', { player: attacker, exp: sharedExp });
                    eventManager.publish('exp_gained', { player: gameState.player, exp: sharedExp });
                }
            }

            // ëª¬ìŠ¤í„° ì‹œì²´ ìƒì„±
            if (victim.unitType === 'monster' && assets.corpse) {
                const corpse = new Item(
                    victim.x,
                    victim.y,
                    this.mapManager.tileSize,
                    'corpse',
                    assets.corpse
                );
                corpse.bobbingSpeed = 0;
                corpse.bobbingAmount = 0;
                corpse.baseY = victim.y;
                this.itemManager.addItem(corpse);
            }
        });

        // ê²Œìž„ì˜¤ë²„ ì´ë²¤íŠ¸ êµ¬ë… ì¶”ê°€
        eventManager.subscribe('game_over', () => {
            gameState.isGameOver = true;
            alert("ê²Œìž„ ì˜¤ë²„!");
            this.combatLogManager.add('%cê²Œìž„ ì˜¤ë²„!');
        });

        eventManager.subscribe('exp_gained', (data) => {
            const { player, exp } = data;
            player.stats.addExp(exp);
        });

        eventManager.subscribe('player_levelup_bonus', (data) => {
            this.gameState.statPoints += data.statPoints;
        });

        eventManager.subscribe('drop_loot', (data) => {
            const lootTable = getMonsterLootTable(data.monsterType);
            const droppedId = rollOnTable(lootTable);
            if (!droppedId) return;

            const startPos = { x: data.position.x, y: data.position.y };
            const endPos = this.findRandomEmptyAdjacentTile(startPos.x, startPos.y);
            if (!endPos) return;

            const item = this.itemFactory.create(droppedId, endPos.x, endPos.y, this.mapManager.tileSize);
            if (!item) return;

            this.vfxManager.addItemPopAnimation(item, startPos, endPos);
        });

        eventManager.subscribe('weapon_disarmed', (data) => {
            if (data.weapon) {
                const context = {
                    eventManager: this.eventManager,
                    itemManager: this.itemManager,
                    equipmentManager: this.equipmentManager,
                    vfxManager: this.vfxManager,
                    mapManager: this.mapManager,
                    ...data
                };
                disarmWorkflow(context);
            }
        });

        eventManager.subscribe('armor_broken', (data) => {
            if (data.armor) {
                const context = {
                    eventManager: this.eventManager,
                    equipmentManager: this.equipmentManager,
                    vfxManager: this.vfxManager,
                    ...data
                };
                armorBreakWorkflow(context);
            }
        });

        // ë¯¸ì‹œì„¸ê³„ íŒì • ê²°ê³¼ í…ìŠ¤íŠ¸ ë° ì¶”ê°€ ì—°ì¶œ
        eventManager.subscribe('micro_world_event', ({ type, entity }) => {
            if (!entity) return;
            if (type === 'disarm') {
                this.vfxManager.showEventText('[ë¬´ìž¥í•´ì œ!]');
            } else if (type === 'armor_break') {
                this.vfxManager.showEventText('[ë°©ì–´êµ¬ íŒŒê´´!]');
            }
        });

        eventManager.subscribe('skill_used', (data) => {
            const { caster, skill, target } = data;
            eventManager.publish('log', { message: `${caster.constructor.name} (ì´)ê°€ ${skill.name} ìŠ¤í‚¬ ì‚¬ìš©!`, color: 'aqua' });
            this.vfxManager.castEffect(caster, skill); // ê¸°ë³¸ ì‹œì „ ì´íŽ™íŠ¸ëŠ” ìœ ì§€

            const mbti = caster.properties?.mbti || '';
            if (skill.id === SKILLS.heal.id || skill.id === SKILLS.guardian_hymn.id || skill.id === SKILLS.courage_hymn.id) {
                if (mbti.includes('S')) this.vfxManager.addTextPopup('S', caster);
                else if (mbti.includes('N')) this.vfxManager.addTextPopup('N', caster);
                if (mbti.includes('E')) this.vfxManager.addTextPopup('E', caster);
                else if (mbti.includes('I')) this.vfxManager.addTextPopup('I', caster);
            }

            // --- ìŠ¤í‚¬ë³„ íŠ¹í™” ì´íŽ™íŠ¸ ë¶„ê¸° ---

            // 1. íž (Heal)
            if (skill.id === SKILLS.heal.id) {
                const healTarget = target || caster;
                const amount = skill.healAmount || 10;
                const prevHp = healTarget.hp;
                healTarget.hp = Math.min(healTarget.maxHp, healTarget.hp + amount);
                const healed = healTarget.hp - prevHp;
                if (healed > 0) {
                    eventManager.publish('log', { message: `${healTarget.constructor.name}ì˜ ì²´ë ¥ì´ ${healed} íšŒë³µë˜ì—ˆìŠµë‹ˆë‹¤.`, color: 'lime' });
                }

                // ê¸°ì¡´ íž ìŠ¤í”„ë¼ì´íŠ¸ ì´íŽ™íŠ¸ ìœ ì§€
                const targetCenter = { x: healTarget.x + healTarget.width / 2, y: healTarget.y + healTarget.height / 2 };
                const healImg = assets['healing-effect'];
                if (healImg) {
                    this.vfxManager.addSpriteEffect(healImg, targetCenter.x, targetCenter.y, {
                        width: healTarget.width,
                        height: healTarget.height,
                        blendMode: 'screen'
                    });
                }

                // ë¶€ë“œëŸ½ê²Œ í”¼ì–´ì˜¤ë¥´ëŠ” ë…¹ìƒ‰ ìž…ìžì™€ ê´‘ì› íš¨ê³¼
                this.vfxManager.addEmitter(targetCenter.x, targetCenter.y + healTarget.height / 2, {
                    spawnRate: 10,
                    duration: 30, // 0.5ì´ˆê°„ ì§€ì†
                    particleOptions: {
                        color: 'rgba(120, 255, 120, 0.8)',
                        gravity: -0.05,
                        lifespan: 90,
                        speed: 1,
                    }
                });
                this.vfxManager.addGlow(targetCenter.x, targetCenter.y, {
                    radius: healTarget.width,
                    colorInner: 'rgba(100, 255, 100, 0.5)',
                    decay: 0.04
                });
            }

            // 2. ìˆ˜í˜¸ì˜ ì°¬ê°€ & ìš©ê¸°ì˜ ì°¬ê°€ (ê·¸ë£¹ ë²„í”„)
            else if (skill.id === SKILLS.guardian_hymn.id || skill.id === SKILLS.courage_hymn.id) {
                const isGuardian = skill.id === SKILLS.guardian_hymn.id;
                const effectId = isGuardian ? 'shield' : 'bonus_damage';
                const particleColor = isGuardian ? 'rgba(50, 150, 255, 0.8)' : 'rgba(255, 100, 50, 0.8)';
                const imgKey = isGuardian ? 'guardian-hymn-effect' : 'courage-hymn-effect';

                const group = this.metaAIManager.groups[caster.groupId];
                const allies = group ? group.members : [caster];

                allies.forEach(ally => {
                    this.effectManager.addEffect(ally, effectId);
                    const allyCenter = { x: ally.x + ally.width / 2, y: ally.y + ally.height / 2 };

                    for (let i = 0; i < 4; i++) {
                        const angle = i * Math.PI / 2;
                        const sx = allyCenter.x + Math.cos(angle) * 100;
                        const sy = allyCenter.y + Math.sin(angle) * 100;
                        this.vfxManager.addHomingBurst(sx, sy, allyCenter, {
                            count: 5,
                            color: particleColor,
                            particleOptions: { homingStrength: 0.08, lifespan: 40, gravity: 0 }
                        });
                    }

                    // ê¸°ì¡´ ë²„í”„ ìŠ¤í”„ë¼ì´íŠ¸ íš¨ê³¼ë„ í•¨ê»˜ ì‚¬ìš©
                    const img = assets[imgKey];
                    if (img) {
                        this.vfxManager.addSpriteEffect(img, allyCenter.x, allyCenter.y, {
                            width: ally.width,
                            height: ally.height,
                            blendMode: 'screen',
                            duration: 30
                        });
                    }
                });
            }

            // 3. ì •í™” (Purify)
            else if (skill.id === SKILLS.purify.id) {
                const purifyTarget = target || caster;
                const targetCenter = { x: purifyTarget.x + purifyTarget.width / 2, y: purifyTarget.y + purifyTarget.height / 2 };

                this.vfxManager.addSpriteEffect(assets['purify-effect'], targetCenter.x, targetCenter.y, {
                    width: purifyTarget.width,
                    height: purifyTarget.height,
                    blendMode: 'screen'
                });
                this.vfxManager.addParticleBurst(targetCenter.x, targetCenter.y, {
                    color: 'rgba(50, 50, 50, 0.7)',
                    count: 15,
                    speed: 2,
                    gravity: 0.01,
                    lifespan: 60
                });
                this.vfxManager.addParticleBurst(targetCenter.x, targetCenter.y, {
                    color: 'rgba(200, 200, 255, 1)',
                    count: 10,
                    speed: 1,
                    gravity: -0.01,
                    lifespan: 70
                });
            }
            // 4. íŒŒì´ì–´ ë…¸ë°”
            else if (skill.id === SKILLS.fire_nova.id) {
                const centerX = caster.x + caster.width / 2;
                const centerY = caster.y + caster.height / 2;
                const radius = skill.effect?.radius || 192;

                this.vfxManager.createNovaEffect(caster, {
                    radius,
                    duration: skill.vfx?.duration || 50,
                    image: skill.vfx?.image || 'fire-nova-effect'
                });

                const enemies = caster.isFriendly ? monsterManager.monsters : [gameState.player, ...mercenaryManager.mercenaries];
                const aoeTargets = findEntitiesInRadius(centerX, centerY, radius, enemies, caster);

                aoeTargets.forEach(enemy => {
                    eventManager.publish('entity_attack', { attacker: caster, defender: enemy, skill });
                    if (skill.effect?.applies?.type === 'burn') {
                        this.effectManager.addEffect(enemy, 'burn');
                    }
                });
            }

            // 5. ê·¸ ì™¸ ê³µê²© ìŠ¤í‚¬ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
            else if (skill.tags.includes('attack')) {
                const range = skill.range || Infinity;
                const nearestEnemy = this.findNearestEnemy(caster, monsterManager.monsters, range);
                if (nearestEnemy) {
                    if (skill.dashRange) {
                        this.motionManager.dashTowards(
                            caster,
                            nearestEnemy,
                            skill.dashRange,
                            monsterManager.monsters,
                            eventManager
                        );
                    }
                    const hits = skill.hits || 1;
                    for (let i = 0; i < hits; i++) {
                        if (skill.projectile) {
                            this.projectileManager.create(caster, nearestEnemy, skill);
                        } else {
                            eventManager.publish('entity_attack', { attacker: caster, defender: nearestEnemy, skill: skill });
                        }
                    }
                } else {
                    eventManager.publish('log', { message: 'ì‹œì•¼ì— ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤.' });
                    caster.mp += skill.manaCost;
                    caster.skillCooldowns[skill.id] = 0;
                }
            }
        });

        eventManager.subscribe('vfx_request', (data) => {
            if (data.type === 'dash_trail') {
                this.vfxManager.createDashTrail(data.from.x, data.from.y, data.to.x, data.to.y, data.options || {});
            } else if (data.type === 'whip_trail') {
                if (this.vfxManager.createWhipTrail) {
                    this.vfxManager.createWhipTrail(data.from.x, data.from.y, data.to.x, data.to.y);
                }
            } else if (data.type === 'text_popup') {
                this.vfxManager.addTextPopup(data.text, data.target, data.options || {});
            } else if (data.type === 'knockback_animation') {
                this.vfxManager.addKnockbackAnimation(data.target, data.fromPos, data.toPos);
            }
        });

        // AIê°€ ì„±ê²© íŠ¹ì„±ì„ ë°œë™í–ˆì„ ë•Œ í…ìŠ¤íŠ¸ íŒì—…ìœ¼ë¡œ í‘œì‹œ
        eventManager.subscribe('ai_mbti_trait_triggered', (data) => {
            if (this.vfxManager) {
                const text = data.tfUsed ? `${data.trait}(tf)` : data.trait;
                this.vfxManager.addTextPopup(text, data.entity);
            }
        });

        // ìŠ¤íƒ¯ ë³€ê²½ ì´ë²¤íŠ¸ êµ¬ë… (íš¨ê³¼ ì ìš©/í•´ì œ ì‹œ ìŠ¤íƒ¯ ìž¬ê³„ì‚°)
        eventManager.subscribe('stats_changed', (data) => {
            data.entity.stats.recalculate();
        });

        // ì¸ë²¤í† ë¦¬ ì—…ë°ì´íŠ¸ ì‹œ UIë¥¼ ìƒˆë¡œ ê³ ì¹©ë‹ˆë‹¤.
        eventManager.subscribe('inventory_updated', ({ involvedEntityIds }) => {
            console.log('Refreshing UI due to inventory update');
            this.uiManager.renderSharedInventory();
            involvedEntityIds.forEach(id => {
                this.uiManager.updateCharacterSheet(id);
                const ent = this.entityManager.getEntityById(id);
                if (ent) this.eventManager.publish('stats_changed', { entity: ent });
            });
        });

        eventManager.subscribe('key_pressed', (data) => {
            const key = data.key;
            if (gameState.isPaused || gameState.isGameOver) return;

            if (['1', '2', '3', '4'].includes(key)) {
                const skillIndex = parseInt(key) - 1;
                const player = gameState.player;
                const skillId = player.skills[skillIndex];

                if (skillId && (player.skillCooldowns[skillId] || 0) <= 0) {
                    const skillData = SKILLS[skillId];
                    if (player.mp >= skillData.manaCost) {
                        player.mp -= skillData.manaCost;
                        player.skillCooldowns[skillId] = skillData.cooldown;
                        eventManager.publish('skill_used', { caster: player, skill: skillData, target: null });
                    } else {
                        eventManager.publish('log', { message: 'ë§ˆë‚˜ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.' });
                    }
                }
            }
        });

        eventManager.subscribe('mouse_wheel', (data) => {
            if (gameState.isPaused || gameState.isGameOver) return;
            const step = 0.1;
            if (data.direction < 0) {
                gameState.zoomLevel = Math.min(2, gameState.zoomLevel + step);
            } else if (data.direction > 0) {
                gameState.zoomLevel = Math.max(0.25, gameState.zoomLevel - step);
            }
        });

        this.uiManager.init({
            onStatUp: this.handleStatUp,
            onItemUse: (itemIndex) => {
                const item = gameState.inventory[itemIndex];
                if (!item) return;

                if (item.baseId === 'potion' || item.name === 'potion') {
                    const playerChar = gameState.player;
                    playerChar.hp = Math.min(playerChar.maxHp, playerChar.hp + 5);
                    this.particleDecoratorManager.playHealingEffect(playerChar);
                    if (item.quantity > 1) {
                        item.quantity -= 1;
                    } else {
                        gameState.inventory.splice(itemIndex, 1);
                    }
                } else if (item.tags.includes('pet') || item.type === 'pet') {
                    this.petManager.equip(gameState.player, item, 'fox');
                } else {
                    const slot = this.inventoryManager.engine.getPreferredSlot(item);
                    if (slot) {
                        this.inventoryManager.engine.moveItem(
                            { entity: gameState.player, slot: 'inventory', index: itemIndex },
                            { entity: gameState.player, slot, index: 0 }
                        );
                    }
                }
                this.uiManager.renderInventory(gameState);
            },
            onConsumableUse: (itemIndex) => {
                const item = gameState.player.consumables[itemIndex];
                if (!item) return;

                if (item.baseId === 'potion' || item.tags?.includes('healing_item')) {
                    const playerChar = gameState.player;
                    playerChar.hp = Math.min(playerChar.maxHp, playerChar.hp + 5);
                    this.particleDecoratorManager.playHealingEffect(playerChar);
                    gameState.player.consumables.splice(itemIndex, 1);
                } else if (item.tags.includes('buff_item')) {
                    this.effectManager.addEffect(gameState.player, item.effectId);
                    gameState.player.consumables.splice(itemIndex, 1);
                } else if (item.tags.includes('pet') || item.type === 'pet') {
                    this.petManager.equip(gameState.player, item, 'fox');
                } else {
                    gameState.player.consumables.splice(itemIndex, 1);
                }
                this.uiManager.updateUI(gameState);
            },
            onEquipItem: (entity, item) => {
                const fromIdx = gameState.inventory.indexOf(item);
                if (fromIdx === -1) return;
                const slot = this.inventoryManager.engine.getPreferredSlot(item);
                if (!slot) return;
                this.inventoryManager.engine.moveItem(
                    { entity: gameState.player, slot: 'inventory', index: fromIdx },
                    { entity, slot, index: 0 }
                );
                this.uiManager.renderInventory(gameState);
                const panel = this.uiManager.openCharacterSheets.get(entity.id);
                if (panel) this.uiManager.renderCharacterSheet(entity, panel);
            }
        });

        // ë‹«ê¸° ë²„íŠ¼ ê³µí†µ ë¡œì§ ìˆ˜ì •
        document.querySelectorAll('.close-btn').forEach(button => {
            button.onclick = () => {
                const panel = button.closest('.modal-panel');
                if (panel) panel.classList.add('hidden');
                this.gameState.isPaused = false;
            };
        });

        // === ìº”ë²„ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸ ì¶”ê°€ (ê°€ìž¥ ìƒë‹¨ weather-canvasì— ì—°ê²°) ===
        this.layerManager.layers.weather.addEventListener('click', (event) => {
            if (gameState.isGameOver) return;

            const rect = this.layerManager.layers.weather.getBoundingClientRect();
            const scale = gameState.zoomLevel;
            const worldX = (event.clientX - rect.left) / scale + gameState.camera.x;
            const worldY = (event.clientY - rect.top) / scale + gameState.camera.y;

            const clickedMerc = [...mercenaryManager.mercenaries].reverse().find(merc =>
                worldX >= merc.x && worldX <= merc.x + merc.width &&
                worldY >= merc.y && worldY <= merc.y + merc.height
            );

            if (clickedMerc) {
                if (this.mercenaryManager.showMercenaryDetail) {
                    this.mercenaryManager.showMercenaryDetail(clickedMerc);
                    this.gameState.isPaused = true;
                }
                return; // ìš©ë³‘ì„ í´ë¦­í–ˆìœ¼ë©´ ë” ì´ìƒ ì§„í–‰ ì•ˆ í•¨
            }

            const clickedMonster = [...monsterManager.monsters].reverse().find(mon =>
                worldX >= mon.x && worldX <= mon.x + mon.width &&
                worldY >= mon.y && worldY <= mon.y + mon.height
            );

            if (clickedMonster) {
                if (this.uiManager.displayCharacterSheet) {
                    this.uiManager.displayCharacterSheet(clickedMonster);
                    this.gameState.isPaused = true;
                }
                return;
            }
        });

        const weatherLayer = this.layerManager.layers.weather;
        weatherLayer.addEventListener('mousedown', (e) => {
            if (this.gameState.currentState === 'WORLD') {
                this.worldEngine.startDrag(e.clientX, e.clientY);
            } else if (this.gameState.currentState === 'COMBAT') {
                this.startDragCamera(e.clientX, e.clientY);
            }
        });
        weatherLayer.addEventListener('mousemove', (e) => {
            if (this.gameState.currentState === 'WORLD') {
                this.worldEngine.drag(e.clientX, e.clientY);
            } else if (this.gameState.currentState === 'COMBAT') {
                this.dragCamera(e.clientX, e.clientY);
            }
        });
        ['mouseup', 'mouseleave'].forEach(ev => {
            weatherLayer.addEventListener(ev, () => {
                if (this.gameState.currentState === 'WORLD') {
                    this.worldEngine.endDrag();
                } else if (this.gameState.currentState === 'COMBAT') {
                    this.endDragCamera();
                }
            });
        });
    }

    findNearestEnemy(caster, enemies, range = Infinity) {
        let nearest = null;
        let minDist = Infinity;
        for (const enemy of enemies) {
            const dx = enemy.x - caster.x;
            const dy = enemy.y - caster.y;
            const dist = Math.hypot(dx, dy);
            if (dist < minDist && dist <= range) {
                minDist = dist;
                nearest = enemy;
            }
        }
        return nearest;
    }

    update = (deltaTime) => {
        if (this.gameState.currentState === 'WORLD') {
            this.worldEngine.update();
            return;
        } else if (this.gameState.currentState === 'FORMATION_SETUP') {
            return;
        } else if (this.gameState.currentState !== 'COMBAT') {
            return;
        }

        this.handleCameraReset();

        const { gameState, mercenaryManager, monsterManager, itemManager, mapManager, inputHandler, effectManager, turnManager, metaAIManager, eventManager, equipmentManager, pathfindingManager, microEngine, microItemAIManager } = this;
        if (gameState.isPaused || gameState.isGameOver) return;

        const allEntities = [gameState.player, ...mercenaryManager.mercenaries, ...monsterManager.monsters, ...(this.petManager?.pets || [])];
        gameState.player.applyRegen();
        effectManager.update(allEntities); // EffectManager ì—…ë°ì´íŠ¸ í˜¸ì¶œ
        turnManager.update(allEntities, { eventManager, player: gameState.player, parasiteManager: this.parasiteManager }); // í„´ ë§¤ë‹ˆì € ì—…ë°ì´íŠ¸
        itemManager.update();
        this.petManager.update();
        if (this.auraManager) {
            this.auraManager.update(allEntities);
        }
        eventManager.publish('debug', { tag: 'Frame', message: '--- Frame Update Start ---' });
        const player = gameState.player;
        if (player.attackCooldown > 0) player.attackCooldown--;
        let moveX = 0, moveY = 0;
        if (inputHandler.keysPressed['ArrowUp']) moveY -= player.speed;
        if (inputHandler.keysPressed['ArrowDown']) moveY += player.speed;
        if (inputHandler.keysPressed['ArrowLeft']) moveX -= player.speed;
        if (inputHandler.keysPressed['ArrowRight']) moveX += player.speed;
        if (moveX !== 0 || moveY !== 0) {
            const targetX = player.x + moveX;
            const targetY = player.y + moveY;
            const monsterToAttack = monsterManager.getMonsterAt(
                targetX + player.width / 2,
                targetY + player.height / 2
            );
            if (monsterToAttack && player.attackCooldown === 0) {
                this.handleAttack(player, monsterToAttack, null);
                const baseCd = 30;
                player.attackCooldown = Math.max(1, Math.round(baseCd / (player.attackSpeed || 1)));
            } else if (!mapManager.isWallAt(targetX, targetY, player.width, player.height)) {
                player.x = targetX;
                player.y = targetY;
            } else {
                if (!mapManager.isWallAt(targetX, player.y, player.width, player.height)) {
                    player.x = targetX;
                } else if (!mapManager.isWallAt(player.x, targetY, player.width, player.height)) {
                    player.y = targetY;
                }
            }
        }
        const itemToPick = this.itemManager.items.find(item =>
            player.x < item.x + mapManager.tileSize &&
            player.x + player.width > item.x &&
            player.y < item.y + mapManager.tileSize &&
            player.y + player.height > item.y
        );
        if (itemToPick) {
            if (itemToPick.baseId === 'gold' || itemToPick.name === 'gold') {
                gameState.gold += 10;
                this.combatLogManager.add(`ê³¨ë“œë¥¼ ì£¼ì› ìŠµë‹ˆë‹¤! í˜„ìž¬ ê³¨ë“œ: ${gameState.gold}`);
            } else if (itemToPick.tags?.includes('consumable')) {
                if (!player.addConsumable(itemToPick)) {
                    const existing = gameState.inventory.find(i => i.baseId === itemToPick.baseId);
                    if (existing) {
                        existing.quantity += 1;
                    } else {
                        gameState.inventory.push(itemToPick);
                    }
                }
                this.combatLogManager.add(`${itemToPick.name}ì„(ë¥¼) íšë“í–ˆìŠµë‹ˆë‹¤.`);
            } else {
                const existing = gameState.inventory.find(i => i.baseId === itemToPick.baseId);
                const invItem = existing || itemToPick;
                if (existing) {
                    existing.quantity += 1;
                } else {
                    gameState.inventory.push(itemToPick);
                }
                this.combatLogManager.add(`${itemToPick.name}ì„(ë¥¼) ì¸ë²¤í† ë¦¬ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.`);
                if (itemToPick.tags.includes('pet') || itemToPick.type === 'pet') {
                    player.addConsumable(invItem);
                    this.petManager.equip(player, invItem, 'fox');
                    // ì•„ì´í…œì€ ê·¸ëŒ€ë¡œ ë³´ìœ í•˜ë„ë¡ ë‚¨ê²¨ë‘”ë‹¤
                }
            }
            this.itemManager.removeItem(itemToPick);
        }
        if (this.fogManager) {
            this.fogManager.update(player, mapManager);
        }
        const context = {
            eventManager,
            player,
            mapManager,
            monsterManager,
            mercenaryManager,
            pathfindingManager,
            laneManager: this.laneManager,
            motionManager: this.motionManager,
            movementManager: this.movementManager,
            projectileManager: this.projectileManager,
            itemManager: this.itemManager,
            equipmentManager: this.equipmentManager,
            vfxManager: this.vfxManager,
            knockbackEngine: this.knockbackEngine,
            supportEngine: this.supportEngine,
            assets: this.loader.assets,
            metaAIManager,
            microItemAIManager,
            playerGroup: this.playerGroup,
            monsterGroup: this.monsterGroup,
            speechBubbleManager: this.speechBubbleManager,
            statusEffectsManager: this.statusEffectsManager,
            enemies: metaAIManager.groups['dungeon_monsters']?.members || []
        };
        metaAIManager.update(context);
        if (this.possessionAIManager) this.possessionAIManager.update(context);
        this.itemAIManager.update(context);
        this.projectileManager.update(allEntities);
        this.vfxManager.update();
        this.speechBubbleManager.update();
        // micro-world engine runs after visuals and item logic
        const allItems = [
            ...this.gameState.inventory,
            ...this.itemManager.items,
            ...this.mercenaryManager.mercenaries.flatMap(m => m.consumables || []),
            ...this.monsterManager.monsters.flatMap(m => m.consumables || []),
        ];
        this.microEngine.update(allItems);
        eventManager.publish('debug', { tag: 'Frame', message: '--- Frame Update End ---' });
    }

    render = () => {
        const { layerManager, gameState, mapManager, itemManager, monsterManager, mercenaryManager, fogManager, uiManager } = this;
        const assets = this.loader.assets;
        const canvas = layerManager.layers.mapBase;

        if (gameState.isGameOver) return;

        layerManager.clear();

        if (gameState.currentState === 'WORLD') {
            this.worldEngine.render(layerManager.contexts.entity);
            if (this.uiManager) this.uiManager.updateUI(gameState);
            return;
        } else if (gameState.currentState === 'FORMATION_SETUP') {
            if (this.uiManager) this.uiManager.updateUI(gameState);
            return;
        } else if (gameState.currentState !== 'COMBAT') {
            return;
        }

        const camera = gameState.camera;
        let zoom = gameState.zoomLevel;

        if (this.cinematicManager.isPlaying) {
            const cameraTarget = this.cinematicManager.targetEntity;
            if (cameraTarget) {
                const targetCameraX = cameraTarget.x - canvas.width / (2 * zoom);
                const targetCameraY = cameraTarget.y - canvas.height / (2 * zoom);
                camera.x += (targetCameraX - camera.x) * 0.08;
                camera.y += (targetCameraY - camera.y) * 0.08;
            }
            const targetZoom = this.cinematicManager.targetZoom;
            zoom += (targetZoom - zoom) * 0.08;
        } else {
            const mapPixelWidth = mapManager.width * mapManager.tileSize;
            const mapPixelHeight = mapManager.height * mapManager.tileSize;
            if (this.cameraDrag.followPlayer) {
                const cameraTarget = gameState.player;
                const targetCameraX = cameraTarget.x - canvas.width / (2 * zoom);
                const targetCameraY = cameraTarget.y - canvas.height / (2 * zoom);
                camera.x = Math.max(0, Math.min(targetCameraX, mapPixelWidth - canvas.width / zoom));
                camera.y = Math.max(0, Math.min(targetCameraY, mapPixelHeight - canvas.height / zoom));
            } else {
                camera.x = Math.max(0, Math.min(camera.x, mapPixelWidth - canvas.width / zoom));
                camera.y = Math.max(0, Math.min(camera.y, mapPixelHeight - canvas.height / zoom));
            }
        }
        gameState.zoomLevel = zoom;

        for (const key in layerManager.contexts) {
            const ctx = layerManager.contexts[key];
            if (ctx.save) {
                ctx.save();
                ctx.scale(zoom, zoom);
                ctx.translate(-camera.x, -camera.y);
            }
        }

        const contexts = layerManager.contexts;

        mapManager.render(contexts.mapBase, contexts.mapDecor, assets);
        this.laneRenderManager.render(contexts.mapDecor);
        itemManager.render(contexts.mapDecor);

        // buffManager.renderGroundAuras(contexts.groundFx, ...); // (ë¯¸ëž˜ êµ¬ë©)

        // Build a unified render queue and sort by Y to get natural overlap.
        // Tie-breaking by id keeps the order stable when Y values are equal.
        const allEntitiesToRender = [
            gameState.player,
            ...(monsterManager?.monsters || []),
            ...(mercenaryManager?.mercenaries || []),
            ...(this.petManager?.pets || [])
        ].filter(e => e && !e.isDying && !e.isHidden);

        allEntitiesToRender.sort((a, b) =>
            a.y === b.y ? a.id.localeCompare(b.id) : a.y - b.y
        );

        const entityCtx = contexts.entity;
        for (const entity of allEntitiesToRender) {
            entity.render(entityCtx);
        }

        if (fogManager) {
            fogManager.render(contexts.vfx, mapManager.tileSize);
        }
        uiManager.renderHpBars(contexts.vfx, gameState.player, monsterManager.monsters, mercenaryManager.mercenaries);
        this.projectileManager.render(contexts.vfx);
        this.vfxManager.render(contexts.vfx);
        this.speechBubbleManager.render(contexts.vfx);
        this.effectIconManager.render(contexts.vfx, [gameState.player, ...monsterManager.monsters, ...mercenaryManager.mercenaries, ...this.petManager.pets], EFFECTS);
        this.cinematicManager.render(contexts.vfx);

        // weatherManager.render(contexts.weather); // (ë¯¸ëž˜ êµ¬ë©)

        for (const key in layerManager.contexts) {
            const ctx = layerManager.contexts[key];
            if (ctx.restore) {
                ctx.restore();
            }
        }

        if (this.uiManager && this.gameState.currentState === 'COMBAT') {
            uiManager.updateUI(gameState);
        }
    }

    handleAttack(attacker, defender, skill = null) {
        this.eventManager.publish('entity_attack', { attacker, defender, skill });
    }

    startDragCamera(screenX, screenY) {
        const { cameraDrag, gameState } = this;
        cameraDrag.isDragging = true;
        cameraDrag.followPlayer = false;
        cameraDrag.dragStart.x = screenX;
        cameraDrag.dragStart.y = screenY;
        cameraDrag.cameraStart.x = gameState.camera.x;
        cameraDrag.cameraStart.y = gameState.camera.y;
    }

    dragCamera(screenX, screenY) {
        const { cameraDrag, gameState, layerManager, mapManager } = this;
        if (!cameraDrag.isDragging) return;
        const zoom = gameState.zoomLevel || 1;
        const deltaX = (screenX - cameraDrag.dragStart.x) / zoom;
        const deltaY = (screenY - cameraDrag.dragStart.y) / zoom;
        gameState.camera.x = cameraDrag.cameraStart.x - deltaX;
        gameState.camera.y = cameraDrag.cameraStart.y - deltaY;
        const canvas = layerManager.layers.mapBase;
        const mapPixelWidth = mapManager.width * mapManager.tileSize;
        const mapPixelHeight = mapManager.height * mapManager.tileSize;
        gameState.camera.x = Math.max(0, Math.min(gameState.camera.x, mapPixelWidth - canvas.width / zoom));
        gameState.camera.y = Math.max(0, Math.min(gameState.camera.y, mapPixelHeight - canvas.height / zoom));
    }

    endDragCamera() {
        this.cameraDrag.isDragging = false;
    }

    // í”Œë ˆì´ì–´ì™€ ëª¨ë“  ê³ ìš©ëœ ìš©ë³‘ì„ í¬í•¨í•˜ëŠ” íŒŒí‹° ëª©ë¡ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    getPartyMembers() {
        const party = [this.player];
        const mercenaries = this.mercenaryManager.getHiredMercenaries();
        return party.concat(mercenaries);
    }

    handleCameraReset() {
        if (!this.cameraDrag.followPlayer && Object.keys(this.inputHandler.keysPressed).length > 0) {
            this.cameraDrag.followPlayer = true;
            this.cameraDrag.isDragging = false;
        }
    }


    /**
     * ì§€ì •ëœ ì¢Œí‘œ ì¸ê·¼ì˜ ë¹„ì–´ ìžˆëŠ” ìž„ì˜ íƒ€ì¼ì„ ì°¾ëŠ”ë‹¤.
     * @param {number} centerX
     * @param {number} centerY
     * @returns {{x:number,y:number}|null}
     */
    findRandomEmptyAdjacentTile(centerX, centerY) {
        const tileSize = this.mapManager.tileSize;
        const baseX = Math.floor(centerX / tileSize);
        const baseY = Math.floor(centerY / tileSize);
        const dirs = [
            { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
            { x: -1, y: 0 },                   { x: 1, y: 0 },
            { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
        ];
        dirs.sort(() => Math.random() - 0.5);

        const entities = [
            this.gameState.player,
            ...this.mercenaryManager.mercenaries,
            ...this.monsterManager.monsters,
        ];

        for (const d of dirs) {
            const tileX = baseX + d.x;
            const tileY = baseY + d.y;
            const worldX = tileX * tileSize;
            const worldY = tileY * tileSize;
            if (this.mapManager.isWallAt(worldX, worldY)) continue;

            const occupied = entities.some(e => {
                const ex = Math.floor(e.x / tileSize);
                const ey = Math.floor(e.y / tileSize);
                return ex === tileX && ey === tileY;
            });
            if (!occupied) {
                return { x: worldX, y: worldY };
            }
        }
        return null;
    }

    handleStatUp = (stat) => {
        if (this.gameState.statPoints > 0) {
            this.gameState.statPoints--;
            this.gameState.player.stats.allocatePoint(stat);
            this.gameState.player.stats.recalculate();
        }
    }

    startBGM() {
        if (this.bgmManager && !this.bgmManager.isInitialized) {
            this.bgmManager.start();
        }
    }
}
