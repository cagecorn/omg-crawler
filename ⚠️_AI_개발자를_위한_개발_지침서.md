현대 게임 프로그래밍 패턴에 대한 종합적 고찰: 핵심 원리부터 고급 응용까지서론게임 개발의 핵심 과제: 복잡성 및 성능 관리게임은 다른 소프트웨어와 구별되는 독특한 특성을 지닙니다. 실시간으로 수많은 상태를 관리해야 하며, 하드웨어의 성능을 극한까지 활용해야 합니다. 이러한 특성은 깨끗하고 관리하기 쉬운 코드를 작성하는 것과 고성능 코드를 작성하는 것 사이에 끊임없는 긴장감을 유발합니다.1 많은 개발자들이 겪는 과정은 명확합니다. 처음에는 간단하게 작동하던 코드가 프로젝트의 규모가 커짐에 따라 걷잡을 수 없이 복잡해지고, 결국 더 나은 구조적 원칙을 찾아 헤매게 됩니다.1 바로 이 지점에서 디자인 패턴이 그 해결책으로 등장합니다.공유된 어휘 및 도구로서의 디자인 패턴의 역할디자인 패턴은 단순히 복사해서 붙여넣을 수 있는 해결책이 아니라, "소프트웨어 설계에서 공통적으로 발생하는 문제에 대한 일반적인 해결책"을 제시합니다.3 이는 개발자들에게 문제 해결을 위한 청사진과 공통된 언어를 제공하여 팀의 의사소통 효율을 높입니다.4 로버트 나이스트롬(Robert Nystrom)의 저서 "게임 프로그래밍 패턴(Game Programming Patterns)"은 이러한 고전적인 소프트웨어 공학 패턴들을 게임 개발이라는 특수한 맥락으로 가져와 코드를 "더 깨끗하고, 이해하기 쉬우며, 더 빠르게" 만드는 데 초점을 맞춘 기념비적인 저작입니다.6본 보고서의 논지: 객체 지향 패턴에서 데이터 지향 아키텍처로의 진화고전적인 객체 지향 프로그래밍(OOP) 기반의 패턴들은 여전히 게임 개발의 근간을 이루고 있습니다.8 하지만 거대한 오픈 월드, 수천 개의 동시 상호작용 개체 등 현대 게임의 극단적인 성능 요구는 새로운 패러다임의 등장을 촉발했습니다. 바로 데이터 지향 설계(Data-Oriented Design, DOD)와 이를 구현하는 핵심 아키텍처인 엔티티-컴포넌트-시스템(Entity-Component-System, ECS)입니다.9 본 보고서는 이러한 진화의 과정을 추적하며, 각 패턴들이 어떻게 서로 관련되고, 적응하며, 때로는 새로운 패러다임에 의해 대체되는지를 심도 있게 탐구할 것입니다.1부: 데이터 지향 패러다임: 현대적 성능의 기초데이터 지향 설계로의 전환은 단순한 성능 최적화 기법을 넘어, 프로그래머의 문제 해결 방식에 대한 근본적인 철학적 변화를 의미합니다. 이는 "객체로 세상을 모델링"하려는 객체 지향적 관점에서 벗어나, "입력 데이터를 출력 데이터로 변환하는 가장 효율적인 방법을 정의"하는 데이터 중심적 관점으로의 이동입니다. 이러한 변화는 개발자가 하드웨어의 근본적인 작동 방식, 특히 CPU 캐시를 이해하도록 강제하며, 게임 엔티티를 구조화하는 방식(ECS)을 바꾸고, 궁극적으로는 초기 개념이 덜 직관적일지라도 훨씬 더 단순하고 예측 가능한 코드를 낳게 됩니다. 데이터 지향 설계의 부상은 CPU 속도가 메모리 접근 속도를 훨씬 앞지르면서 발생한 "CPU-메모리 성능 격차"의 직접적인 결과물이며, 이로 인해 데이터 접근 패턴이 게임과 같은 성능 집약적 애플리케이션의 주요 병목 현상이 되었기 때문입니다.1.1 패러다임의 전환: 객체 지향에서 데이터 지향 설계로상속의 한계전통적인 객체 지향 프로그래밍은 깊은 상속 계층 구조에 의존하는 경향이 있습니다. 예를 들어, 고블린 클래스는 몬스터를 상속하고, 몬스터는 캐릭터를, 캐릭터는 게임오브젝트를 상속하는 식입니다. 이러한 구조는 경직되기 쉽고, 다중 상속 시 발생하는 "죽음의 다이아몬드(Deadly Diamond of Death)" 문제나 거대한 기본 클래스로 인해 다양한 종류의 엔티티를 유연하게 생성하기 어렵게 만듭니다.11 따라서 현대 아키텍처의 목표는 "상속보다 컴포지션(Composition over Inheritance)"을 선호하는 방향으로 진화했습니다.13데이터 지향 설계(DOD)의 도입데이터 지향 설계의 핵심 교리는 "데이터의 변환이 모든 프로그램의 유일한 목적이다"라는 마이크 액톤(Mike Acton)의 말에 집약되어 있습니다.15 DOD는 코드가 어떻게 구성되는지보다 데이터 자체와 메모리상의 데이터 레이아웃을 최우선으로 고려합니다.9 이는 추상적인 개념을 모델링하는 것에서 벗어나, "입력 데이터는 무엇이며, 원하는 출력 데이터는 무엇인가?"라는 구체적인 문제를 이해하는 것으로의 관점 전환을 요구합니다.17 즉, 게임을 일련의 데이터 변환 파이프라인으로 간주하게 됩니다.18데이터와 로직의 분리데이터와 로직의 분리는 DOD를 실질적으로 구현하는 방식입니다. 데이터는 순수하고 간단한 구조체(주로 "컴포넌트"라 불림)에 저장되고, 해당 데이터에 대한 로직은 별도의 함수나 클래스(주로 "시스템"이라 불림)에 담깁니다.11 이 분리 원칙이 바로 ECS 아키텍처의 근간을 이룹니다.1.2 CPU 캐시: 데이터 지향 설계를 이끄는 하드웨어의 현실CPU-메모리 성능 격차현대 CPU의 연산 속도는 주 메모리(RAM)의 접근 속도보다 수십, 수백 배 빠릅니다. 이 엄청난 속도 차이를 메우기 위해 CPU는 L1, L2, L3와 같이 여러 단계로 구성된 작고 빠른 메모리, 즉 캐시(Cache)를 사용합니다.20캐시 미스의 비용CPU가 필요로 하는 데이터가 캐시에 없는 경우(이를 "캐시 미스(Cache Miss)"라고 함), CPU는 작동을 멈추고 주 메모리에서 데이터를 가져올 때까지 수백 사이클을 허비하게 됩니다.21 따라서 캐시 미스를 줄이는 것은 성능 지향 프로그래밍의 가장 중요한 목표 중 하나입니다.20데이터 지역성과 캐시 라인CPU는 메모리에서 데이터를 바이트 단위로 가져오지 않습니다. 대신, "캐시 라인(Cache Line)"이라는 고정된 크기(보통 64바이트)의 덩어리로 데이터를 가져옵니다.22 이는 성능 최적화에 중요한 시사점을 줍니다. 어떤 데이터를 처리할 때, 그 다음에 필요할 데이터가 이미 캐시에 존재하도록 만들면 성능을 극대화할 수 있습니다. 즉, 함께 사용될 데이터는 메모리상에 가깝게 배치해야 합니다. 이를 공간적 지역성(Spatial Locality) 이라고 합니다.캐시 일관성과 캐시 활용률캐시 일관성(Cache Coherency): 이는 멀티코어 시스템에서 발생하는 특정 문제로, 모든 코어가 공유 메모리에 대해 일관된 데이터를 보도록 보장하는 메커니즘입니다. 데이터의 정확성에 관한 문제입니다.23캐시 활용률(Cache Utilization): DOD의 맥락에서 개발자들이 종종 "캐시 일관성"이라고 잘못 말하는 개념은 실제로는 캐시 활용률 또는 *캐시 친화성(Cache-friendliness)*을 의미합니다. 이는 캐시 미스를 최소화하기 위해 데이터를 정렬하는 행위를 말합니다.21 본 보고서에서는 이 용어를 명확히 구분하여 사용합니다.구조체의 배열(AoS) vs. 배열의 구조체(SoA)이는 캐시 활용률을 높이기 위한 데이터 지향 설계의 정수와도 같은 기법입니다.구조체의 배열 (Array of Structures, AoS - 전통적 OOP 방식):struct Object { Vector3 pos; Vector3 vel; float health; }; Object objects;이 경우 메모리에는 [pos,vel,health], [pos,vel,health],... 형태로 데이터가 저장됩니다. 만약 물리 시스템이 오직 위치(pos) 정보만을 갱신하기 위해 이 배열을 순회한다면, 각 객체에 대해 pos뿐만 아니라 불필요한 vel과 health 데이터까지 캐시 라인으로 함께 불러오게 됩니다. 이는 캐시를 오염시키고 더 많은 캐시 미스를 유발합니다.22배열의 구조체 (Structure of Arrays, SoA - 데이터 지향 방식):struct Objects { Vector3 positions; Vector3 velocities; float healths; };이 경우 메모리에는 [pos,pos,pos,...], [vel,vel,vel,...], [health,health,health,...] 형태로 데이터가 저장됩니다. 이제 물리 시스템이 위치 정보만 순회할 때, 캐시 라인에 로드되는 모든 데이터는 다른 위치 정보가 됩니다. 이는 공간적 지역성을 극대화하여 캐시 미스를 획기적으로 줄이고, 특히 SIMD(Single Instruction, Multiple Data) 연산의 효율을 크게 높입니다.22속성구조체의 배열 (AoS)배열의 구조체 (SoA)코드 정의struct Object { float x, y, z; }; Object objects[N];struct Objects { float x[N]; float y[N]; float z[N]; };메모리 레이아웃[xyz], [xyz], [xyz],... (데이터 혼재)[xxx...], [yyy...], [zzz...] (데이터 분리 및 연속)단일 시스템 접근 시 캐시 성능비효율적: 특정 시스템(예: 물리)이 x만 필요로 해도 불필요한 y, z 데이터가 캐시를 오염시킴.22매우 효율적: x 데이터를 순회할 때 캐시 라인에 x 데이터만 채워져 공간적 지역성이 극대화됨.22단일 객체 전체 접근 시 캐시 성능효율적: 한 객체의 모든 데이터(x, y, z)가 이미 메모리상에 모여 있음.29비효율적: 한 객체의 데이터를 얻기 위해 여러 메모리 위치(x 배열, y 배열, z 배열)에 접근해야 함.SIMD 친화성낮음: SIMD는 동일한 타입의 데이터 묶음에 대해 단일 명령을 실행하는 데, 데이터가 혼재되어 있어 비효율적임.높음: 동일한 타입의 데이터가 연속적으로 배치되어 있어 SIMD 연산에 이상적임.261.3 엔티티-컴포넌트-시스템(ECS) 아키텍처컴포넌트 패턴으로부터의 진화컴포넌트 패턴 (Component Pattern): 이 패턴은 물리, 렌더링과 같은 각 도메인을 개별 컴포넌트 객체로 캡슐화하고, 이를 GameObject라는 컨테이너에 조합하는 방식입니다. 이는 상속의 한계를 극복하는 중요한 진전입니다.12ECS로의 발전: 하지만 이 방식에서도 GameObject는 여전히 무거운 객체이며, 컴포넌트 간의 통신은 복잡하고 비효율적일 수 있습니다.12 ECS는 이러한 컴포넌트 아이디어를 데이터 지향적으로 극단까지 밀어붙인 급진적인 진화입니다.5순수 ECS의 세 가지 기둥엔티티 (Entity): 고유한 정수 ID에 불과합니다. 데이터도, 메서드도 가지지 않습니다. 컴포넌트들을 하나로 묶어주는 열쇠일 뿐입니다.11컴포넌트 (Component): 순수한 데이터 덩어리입니다. 로직이 없는 struct와 같습니다. 예를 들어 PositionComponent, VelocityComponent, HealthComponent 등이 있습니다.13 이들은 캐시 효율성을 위해 연속적인 SoA 스타일 배열로 저장됩니다.시스템 (System): 순수한 로직입니다. 특정 컴포넌트 조합을 가진 모든 엔티티를 순회하며 작업을 수행하는 함수입니다. 예를 들어, PhysicsSystem은 PositionComponent와 VelocityComponent를 모두 가진 모든 엔티티를 순회하며 위치를 업데이트합니다.11ECS가 DOD와 병렬 처리를 가능하게 하는 방법ECS는 설계적으로 데이터와 로직의 분리를 강제하고 SoA 데이터 레이아웃을 장려하므로, 본질적으로 캐시 친화적입니다.13 또한, 각 시스템은 독립적이고 명확하게 정의된 데이터 집합에 대해서만 작동하므로 병렬화에 매우 유리합니다. PhysicsSystem과 AISystem은 종종 서로 다른 CPU 코어에서 동시에 실행될 수 있으며, 이는 Unity의 C# 잡 시스템(Job System)과 같은 프레임워크가 제공하는 핵심적인 이점입니다.10실제 적용 사례블리자드의 **오버워치(Overwatch)**는 최첨단 ECS 아키텍처를 사용하여 다양한 영웅들의 복잡성을 관리하고 반응성 높은 멀티플레이어 게임플레이를 보장합니다.38Unity의 **DOTS(Data-Oriented Technology Stack)**는 상용 엔진에 구현된 완전한 형태의 ECS 프레임워크입니다.10**언리얼 엔진(Unreal Engine)**은 전통적으로 객체 지향적이지만, 시퀀서(Sequencer)와 같은 성능 집약적인 영역에 ECS 원칙을 도입하고 있습니다.40 언리얼 엔진의 컴포넌트는 로직을 포함할 수 있기 때문에, 순수 ECS와 구분하여 "엔티티-컴포넌트(EC)" 모델로 불리기도 합니다.332부: 필수 게임 프로그래밍 패턴 카탈로그패턴 이름카테고리 (Nystrom 기준)해결하는 핵심 문제게임에서의 주요 이점커맨드 (Command)행동 (Behavioral)행동의 요청과 실행을 분리하여 '무엇을', '누가', '언제' 할지를 분리함실행 취소/다시 실행, 입력 리매핑, AI 커맨드 큐 구현을 가능하게 함플라이웨이트 (Flyweight)최적화 (Optimization)수많은 유사 객체 간에 공유 가능한 상태를 분리하여 메모리 사용량을 최소화함수천 개의 나무, 파티클 등을 효율적으로 렌더링하여 메모리를 절약함옵저버 (Observer)디커플링 (Decoupling)한 객체(Subject)가 자신의 상태 변화를 다른 객체들(Observers)에게 직접 알지 못하면서 통지함업적 시스템, UI 업데이트, 오디오 트리거 등 시스템 간의 느슨한 결합을 구현함상태 (State)행동 (Behavioral)객체의 내부 상태에 따라 행동이 바뀌도록 하여, 거대한 조건문을 제거하고 상태별 로직을 캡슐화함플레이어 캐릭터의 상태(서기, 점프, 숙이기 등)나 AI의 행동 상태를 명확하게 관리함게임 루프 (Game Loop)시퀀싱 (Sequencing)게임 시간의 흐름을 사용자 입력 및 하드웨어 속도로부터 분리함하드웨어 성능과 무관하게 일관된 게임 속도와 안정적인 물리 시뮬레이션을 보장함타입 객체 (Type Object)행동 (Behavioral)새로운 '타입'을 코드가 아닌 데이터로 정의할 수 있게 하여 유연성을 높임몬스터, 아이템, 마법 등의 다양한 종류를 데이터 파일로 정의하여 런타임에 생성함서브클래스 샌드박스 (Subclass Sandbox)행동 (Behavioral)서브클래스가 기본 클래스가 제공하는 안전한 연산 집합(샌드박스) 내에서만 동작하도록 강제함서브클래스와 엔진 하위 시스템 간의 결합도를 낮추고 코드 중복을 줄임이벤트 큐 (Event Queue)디커플링 (Decoupling)이벤트 발생과 처리를 시간적으로 분리하여 동기적 호출로 인한 성능 병목을 방지함옵저버 패턴의 동기적 블로킹 문제를 해결하고, 스레드 간 통신을 가능하게 함서비스 로케이터 (Service Locator)디커플링 (Decoupling)구체적인 클래스에 대한 결합 없이 전역적인 서비스(오디오, 물리 등)에 접근할 수 있는 방법을 제공함싱글턴 패턴의 대안으로, 서비스 구현을 쉽게 교체할 수 있게 함오브젝트 풀 (Object Pool)최적화 (Optimization)빈번한 객체 생성 및 소멸로 인한 성능 저하와 메모리 파편화를 방지함총알, 파티클, 적 유닛 등 자주 생성되고 파괴되는 객체를 재활용하여 성능을 향상시킴공간 분할 (Spatial Partition)최적화 (Optimization)월드 내 객체들을 위치 기반 자료구조로 정리하여 충돌 검사와 같은 공간 탐색 비용을 줄임O(n^2)의 충돌 검사를 피하고, 가시성 판단(culling) 등의 효율을 높임2.1 디자인 패턴 재방문 (게임 맥락에서의 GoF 패턴)많은 고전적인 GoF(Gang of Four) 디자인 패턴들은 게임 개발 환경에서 가장 강력하고 문자 그대로의 응용 사례를 찾습니다. 텍스트 편집기의 "실행 취소"는 추상적이지만, 게임에서 "움직임 취소"는 커맨드 패턴에 완벽하게 부합하는 구체적이고 실체적인 기능입니다. 마찬가지로, 플라이웨이트 패턴의 메모리 절약 효과는 게임에서 흔히 볼 수 있는 수천 그루의 나무나 파티클을 렌더링할 때 그 진가를 발휘합니다.커맨드 패턴 (Command Pattern)문제 및 의도: 요청을 하나의 객체로 캡슐화하여("메서드 호출을 객체화(reify)함" 41), 요청을 발행하는 객체와 그 요청을 수행하는 객체를 분리하는 것이 목적입니다.42 요청자(Invoker)는 커맨드가 무엇을 하는지 알 필요 없이, 단지 execute() 메서드를 호출할 수 있다는 사실만 알면 됩니다.41구조: Client가 ConcreteCommand를 생성하고 이를 Receiver와 연결합니다. Client는 이 커맨드를 Invoker에게 전달하고, Invoker가 execute()를 호출하면 ConcreteCommand가 Receiver에 대한 실제 행동을 수행합니다.42게임 사용 사례:입력 처리: 키나 버튼 입력을 직접적인 함수 호출 대신 커맨드 객체에 매핑합니다. 이를 통해 런타임에 조작 키를 쉽게 재설정할 수 있습니다.41실행 취소/다시 실행 (Undo/Redo): 실행된 커맨드 객체들을 스택에 쌓아둡니다. 실행을 취소하려면 스택에서 커맨드를 꺼내(pop) undo() 메서드를 호출합니다. 이 때 커맨드 객체는 행동을 되돌리는 데 필요한 상태(예: 유닛의 이전 위치)를 스스로 저장하고 있어야 합니다.41인공지능 (AI): AI 에이전트가 MoveToCommand, AttackCommand와 같은 커맨드 큐를 생성하여 유닛이 시간에 따라 순차적으로 실행하도록 할 수 있습니다. 이는 AI의 의사 결정 로직과 유닛의 실제 행동 실행을 분리합니다.49네트워킹 및 리플레이: 커맨드 객체 스트림을 직렬화하여 네트워크를 통해 전송하거나 파일에 저장하여 리플레이 기능을 구현할 수 있습니다.41장점: 요청자와 수신자의 분리(Decoupling) 43, 확장성(개방-폐쇄 원칙) 44, 큐잉, 로깅, 실행 취소/다시 실행 기능 구현 용이.43단점: 간단한 기능에 대해서도 수많은 작은 클래스를 만들어야 하므로 복잡성이 증가할 수 있습니다.43플라이웨이트 패턴 (Flyweight Pattern)문제 및 의도: 수많은 유사 객체들 사이에서 가능한 많은 데이터를 공유하여 메모리 사용량을 최소화하는 것이 목적입니다.52구조: 객체의 상태를 두 가지로 분리합니다.내재적 상태 (Intrinsic State): 공유 가능하고, 문맥에 독립적인 데이터입니다 (예: 나무의 메시와 텍스처). 이 데이터는 Flyweight 객체 자체에 저장됩니다.52외재적 상태 (Extrinsic State): 각 인스턴스마다 고유하고, 문맥에 의존적인 데이터입니다 (예: 나무의 위치, 크기, 색상). 이 데이터는 클라이언트 코드에 의해 저장되거나 계산되어 필요할 때 플라이웨이트의 메서드에 인자로 전달됩니다.54FlyweightFactory는 플라이웨이트 객체 풀을 관리하며, 고유한 내재적 상태가 요청될 때만 새로운 플라이웨이트를 생성합니다.54게임 사용 사례:환경 렌더링: 수천 그루의 나무로 이루어진 숲을 렌더링할 때, 모든 나무가 공유하는 하나의 TreeModel 플라이웨이트(메시, 텍스처)를 두고, 각 나무 인스턴스는 고유한 변환 정보(위치, 회전, 크기)만 저장합니다.54파티클 시스템: 연기, 불꽃 등 각 파티클 타입이 플라이웨이트가 되고, 각 파티클 인스턴스는 위치, 속도, 생명 시간 등 고유한 정보만 가집니다.타일 기반 지형: 풀, 모래, 물 등 각 지형 타일 타입이 이동 비용과 텍스처를 가진 플라이웨이트가 됩니다. 월드 그리드는 이 플라이웨이트에 대한 참조만 저장합니다.56장점: 막대한 메모리 절약 효과를 가져오며, 이는 더 적은 캐시 미스와 처리할 데이터 감소로 이어져 성능 향상을 유도할 수 있습니다.55단점: 코드 복잡성이 증가합니다. 객체의 상태가 플라이웨이트와 클라이언트 코드 양쪽에 나뉘어 존재하므로 코드를 이해하기 더 어려워질 수 있습니다.54 명확한 메모리 문제가 있을 때만 적용해야 하는 최적화 기법입니다.54옵저버 패턴 (Observer Pattern)문제 및 의도: 객체 간에 일대다(one-to-many) 의존 관계를 정의하여, 한 객체(Subject)의 상태가 변할 때 그 객체에 의존하는 모든 객체(Observer)들이 자동으로 통지받고 갱신되도록 하는 것입니다. 이때 Subject는 Observer의 구체적인 클래스를 알 필요가 없습니다.57구조: Subject는 Observer 객체들의 목록을 유지하며, addObserver와 removeObserver 메서드를 제공합니다. 이벤트가 발생하면 Subject는 notify() 메서드를 호출하고, 이 메서드는 목록을 순회하며 각 Observer의 onNotify() 메서드를 호출합니다.59게임 사용 사례:업적 시스템: 물리 시스템(Subject)이 "엔티티가 떨어졌다"는 사실을 통지하면, 업적 시스템(Observer)이 이 이벤트를 수신하여 "다리에서 떨어지기"와 같은 특정 조건이 충족되었는지 확인하고 업적을 해제합니다.59UI 업데이트: 플레이어의 체력 데이터(Subject)가 변경될 때마다 UI 체력 바(Observer)에 통지하여 화면을 갱신합니다.오디오 트리거: 애니메이션 시스템(Subject)이 공격 애니메이션의 타격 프레임에 도달했음을 통지하면, 오디오 시스템(Observer)이 이에 반응하여 "휙"하는 효과음을 재생합니다.60이벤트 시스템: 대부분의 게임 이벤트 시스템의 핵심입니다. 중앙의 EventManager가 다양한 게임 이벤트에 대한 Subject 역할을 할 수 있습니다.61장점: 시스템 간의 결합도를 매우 낮춥니다(Loose Coupling).59 확장성이 매우 뛰어납니다.59단점:동기적 실행: Subject는 모든 Observer가 알림 처리를 마칠 때까지 대기(block)하므로, 느린 Observer가 있으면 성능 문제를 유발할 수 있습니다.59 이 문제를 해결하기 위해 이벤트 큐 패턴이 사용됩니다.메모리 누수 (Lapsed Listener Problem): Observer가 파괴될 때 Subject에서 자신을 제거(unregister)하지 않으면, Subject가 소멸된 Observer에 대한 참조(댕글링 포인터)를 계속 들고 있거나 가비지 컬렉션을 방해할 수 있습니다.57디버깅의 복잡성: 제어 흐름이 동적이고 간접적이어서 추적하기 어려울 수 있습니다.59상태 패턴 (State Pattern)문제 및 의도: 객체가 내부 상태가 변함에 따라 자신의 행동을 바꾸도록 하는 것입니다. 이를 통해 객체는 마치 자신의 클래스를 바꾸는 것처럼 보이게 됩니다.63 이 패턴은 상태 관리를 위한 거대하고 버그가 발생하기 쉬운 if/else 또는 switch 문을 피하게 해줍니다.63구조: 주 객체(Context, 예: Heroine)는 현재 상태를 나타내는 State 객체에 대한 포인터를 가집니다. 모든 상태 종속적인 행동은 현재 State 객체에 위임됩니다. 상태를 변경하려면, Context는 단순히 다른 State 인스턴스를 가리키도록 포인터를 바꾸기만 하면 됩니다. 각 구체적인 상태(예: JumpingState, DuckingState)는 공통 State 인터페이스를 구현합니다.63게임 사용 사례:플레이어 캐릭터 제어: 캐릭터가 서 있는지, 걷는지, 점프하는지, 숙이는지 등의 상태를 관리합니다. 각 상태는 입력과 업데이트를 다르게 처리합니다.63AI 행동: 적의 상태가 순찰 중, 추격 중, 공격 중, 도망 중 등으로 바뀔 수 있습니다.게임 흐름 관리: 메뉴 화면, 로딩 화면, 실제 게임 플레이 상태 등을 관리합니다.장점: 상태별 코드를 깔끔하게 정리하고, 복잡한 조건문을 제거하며, 유효하지 않은 상태 조합을 방지합니다.63단점: 상태마다 새로운 클래스가 필요하여 클래스 수가 많아질 수 있습니다. 매우 단순한 유한 상태 기계(FSM)의 경우, switch 문이 더 간단할 수 있습니다.632.2 시퀀싱 및 행동 패턴게임 루프 (Game Loop)목적: 전체 게임을 구동하는 중앙 루프입니다. 입력을 처리하고, 게임 로직을 업데이트하며, 장면을 렌더링합니다. 이 패턴의 주된 아키텍처적 과제는 게임 시뮬레이션의 속도를 사용자의 입력 속도 및 하드웨어의 처리 속도로부터 분리하는 것입니다.64구현 방식 및 장단점:가변 시간 단계 (Variable Timestep): 이전 프레임 이후 경과된 실제 시간을 측정하여 이 deltaTime을 업데이트 로직에 전달합니다. 장점: 고사양 기기에서 부드럽게 보입니다. 단점: 물리 시뮬레이션이 불안정해지고 비결정론적(non-deterministic) 행동으로 이어질 수 있어, 네트워크 게임이나 복잡한 물리 연산에는 부적합합니다.64고정 시간 단계 (Fixed Timestep): 게임 로직을 고정된 시간 간격(예: 1/60초)으로 업데이트합니다. 게임이 느리게 실행되면 렌더링 한 프레임당 여러 번의 업데이트를 수행하여 "따라잡습니다". 장점: 결정론적이고 안정적인 물리/AI를 보장합니다. 단점: 구현이 더 복잡하며, 렌더링과 업데이트가 동기화되지 않으면 화면 끊김(stutter)이 발생할 수 있습니다.64 이것이 전문가들이 선호하는 방식입니다.보간을 사용한 고정 시간 단계: 표준적인 전문 해결책입니다. 게임 상태는 고정된 속도로 업데이트되지만, 렌더링은 이전 상태와 현재 상태 사이를 보간(interpolate)하여 렌더링 속도가 변동하더라도 부드러운 시각적 결과물을 만들어냅니다.64타입 객체 (Type Object)문제 및 의도: 새로운 클래스를 작성하지 않고도 런타임에 새로운 "타입"의 객체를 생성할 수 있도록 합니다. 이는 타입 정의를 경직된 코드에서 유연한 데이터로 옮기는 것입니다.65 이로써 단지 몇몇 데이터 값만 다른 수많은 서브클래스가 폭발적으로 증가하는 것을 방지합니다.66구조: 한 객체(Monster)가 "타입 객체"(Breed)에 대한 참조를 가집니다. 특정 타입의 모든 몬스터가 공유하는 데이터(예: "트롤"의 체력, 공격 문구)는 Breed 객체에 저장되고, 각 인스턴스에 고유한 데이터(예: 현재 체력)는 Monster 객체 자체에 저장됩니다.65게임 사용 사례: 다양한 종류의 몬스터, 아이템, 마법, 캐릭터 클래스 등을 하드코딩하는 대신 데이터 파일(예: JSON 또는 Unity의 ScriptableObject)로부터 정의합니다.66플라이웨이트와의 관계: 두 패턴 모두 공유 상태와 고유 상태를 분리합니다. 하지만 플라이웨이트의 의도는 순전히 메모리 최적화인 반면, 타입 객체의 의도는 데이터 내에서 타입 시스템의 유연성을 제공하는 것입니다.56서브클래스 샌드박스 (Subclass Sandbox)문제 및 의도: 서브클래스에서 행동을 정의하되, 해당 서브클래스와 나머지 엔진 간의 결합을 최소화하는 것입니다. 기본 클래스는 서브클래스가 반드시 사용해야 하는 안전하고 고수준의 "제공된 연산들"(샌드박스)을 제공합니다.69구조: 기본 클래스(Superpower)는 보호된(protected) 추상 메서드 activate()를 가집니다. 서브클래스(SkyLaunch, GroundPound)는 playSound(), spawnParticles(), move()와 같이 기본 클래스가 제공하는 보호된 메서드들을 호출하여 activate()를 구현합니다. 기본 클래스는 오디오 및 물리 엔진과 통신하는 복잡한 세부 사항을 처리합니다.69장점: 코드 중복을 줄이고, 서브클래스를 저수준 엔진 시스템으로부터 분리시킵니다.69단점: 너무 많은 시스템과 결합되어 변경하기 어려운 "취약한 기본 클래스(brittle base class)"를 만들 수 있습니다.692.3 디커플링 및 최적화 패턴이 패턴들은 고수준 아키텍처에 관한 것이라기보다는, 구현 과정에서 반복적으로 발생하는 특정 문제들을 해결하는 데 중점을 둡니다. 이는 크고 복잡한 아키텍처를 성능 좋고 유지보수 가능하게 만드는 "너트와 볼트"와 같습니다. 예를 들어, 옵저버 패턴이 시스템을 개념적으로 분리한다면, 이벤트 큐는 시스템을 시간적으로 분리하여 성능 병목을 방지합니다.이벤트 큐 (Event Queue)문제 및 의도: 송신자와 수신자를 시간적으로 분리합니다. Subject가 즉시 동기적으로 Observer를 호출하는 대신, 이벤트/알림을 큐에 넣습니다. 그러면 Observer는 나중에 더 편리한 시간에 큐에서 이벤트를 가져와 처리합니다.7장점: 옵저버 패턴의 동기적 블로킹 문제를 해결합니다. 스레드 간 통신을 가능하게 합니다. 이벤트 스트림을 일시 중지하거나 다시 재생하는 등 강력한 기능을 구현할 수 있습니다.구현: 종종 중앙의 전역 큐를 사용합니다. 큐에 대한 읽기와 쓰기 간의 경합을 피하기 위해 더블 버퍼(Double Buffer)로 구현할 수 있습니다.서비스 로케이터 (Service Locator)문제 및 의도: 서비스(오디오 엔진, 업적 시스템 등)를 사용하는 쪽이 해당 서비스를 구현하는 클래스에 결합되지 않으면서 전역적으로 서비스에 접근할 수 있도록 합니다.8 이는 종종 비판받는 싱글턴(Singleton) 패턴의 대안입니다.구조: 전역 Locator 클래스는 서비스 인스턴스를 register()하고 get()하는 정적 메서드를 가집니다. 코드는 구체적인 클래스가 아닌 인터페이스를 통해 서비스를 요청합니다.장점: 코드를 구체적인 서비스 클래스로부터 분리합니다. 구현을 쉽게 교체할 수 있습니다 (예: 테스트를 위한 null 오디오 서비스).단점: 의존성이 여전히 숨겨져 있습니다. 여전히 전역적인 접근 방식이므로 코드를 이해하고 테스트하기 어렵게 만들 수 있습니다. 현대적인 접근 방식은 명시적인 *의존성 주입(Dependency Injection)*을 선호하는 경향이 있습니다.오브젝트 풀 (Object Pool)문제 및 의도: 빈번한 객체 할당 및 해제로 인한 성능 비용과 메모리 파편화를 줄이는 것이 목적입니다.7구조: 풀(Pool)은 미리 할당된 재사용 가능한 객체들의 목록을 관리합니다. 객체가 필요할 때 풀에서 가져오고, 더 이상 필요하지 않을 때 파괴하는 대신 풀에 반환합니다.게임 사용 사례: 총알, 파티클 효과, 자주 생성되고 파괴되는 적들.공간 분할 (Spatial Partition)문제 및 의도: 위치를 기반으로 씬(scene)에 있는 객체를 효율적으로 찾기 위함입니다. 이를 통해 충돌 감지와 같은 O(n^2) 복잡도의 검사를 피할 수 있습니다.7구조: 게임 월드를 자료구조로 분할합니다. 일반적인 예로는 그리드(Grid), 쿼드트리(Quadtree, 2D용), 옥트리(Octree, 3D용)가 있습니다. 충돌을 확인할 때, 한 객체는 동일하거나 인접한 분할 영역에 있는 다른 객체들과만 검사하면 됩니다.3부: 현대 엔진에서의 종합 및 실제 적용3.1 현대 엔진에서의 패턴 시너지이전 파트들의 내용을 종합하여, 가상적이지만 현실적인 게임 프레임의 동작을 통해 패턴들이 어떻게 시너지를 내는지 살펴보겠습니다.게임 루프 64가 시작됩니다. 입력을 처리하여 커맨드 객체 41를 생성하고, 이를 플레이어 엔티티로 보냅니다.루프는 고정 업데이트 단계에 진입합니다. ECS 시스템(예: PhysicsSystem) 32이 실행되어, SoA 스타일의 Position 및 Velocity 컴포넌트 배열 28을 순회합니다.충돌이 발생하면, 시스템은 다른 시스템을 직접 호출하는 대신 "Collision" 이벤트를 이벤트 큐 8에 넣습니다.나중에 다른 시스템이 이 이벤트를 꺼내 몬스터가 죽었다고 판단합니다. 이 시스템은 몬스터를 오브젝트 풀 8에 반환하고, 옵저버인 AchievementSystem 59에 알림을 보냅니다.렌더링 단계에서는 공간 분할 7을 사용하여 어떤 객체가 보이는지 결정합니다. 숲을 렌더링할 때는 나무에 대해 플라이웨이트 패턴 56을 사용합니다.3.2 사례 연구: Unity의 데이터 지향 기술 스택 (DOTS)순수 ECS/DOD 구현으로서의 DOTSUnity DOTS는 이러한 현대적 원칙들을 상용 엔진에 적용한 교과서적인 예입니다.10핵심 구성 요소ECS for Unity: 엔티티, 컴포넌트, 시스템 아키텍처를 제공합니다.10 이는 전통적인 GameObject 및 MonoBehaviour 작업 흐름으로부터의 패러다임 전환입니다.71C# 잡 시스템 (Job System): 안전한 멀티스레드 코드를 작성하기 위한 프레임워크로, 시스템들을 여러 CPU 코어에 걸쳐 병렬화할 수 있게 해줍니다.10버스트 컴파일러 (Burst Compiler): C# 코드를 고도로 최적화된 네이티브 기계 코드로 변환하는 AOT(Ahead-of-Time) 컴파일러로, C++에 가까운 성능을 이끌어냅니다.10장점과 과제DOTS는 막대한 성능 향상을 가능하게 하여, 수천 개의 엔티티를 가진 게임(예: V Rising, Diplomacy is Not an Option)을 만들 수 있게 합니다.10 하지만 전통적인 OOP에 비해 학습 곡선이 가파르고 다른 방식의 사고를 요구합니다.713.3 사례 연구: 언리얼 엔진의 액터-컴포넌트 모델강력한 하이브리드 접근 방식언리얼 엔진의 아키텍처는 AActor와 UComponent를 중심으로 구축되어 있습니다.33 이는 근본적으로 객체 지향적이지만 컴포넌트 패턴을 매우 적극적으로 사용합니다.순수 ECS와의 주요 차이점언리얼에서 AActor는 단순한 ID가 아닌 무거운 객체이며, UComponent는 데이터뿐만 아니라 로직(예: 자체 Tick 함수)도 포함할 수 있습니다.33이로 인해 언리얼은 순수한 "ECS"가 아닌 "EC"(엔티티-컴포넌트) 시스템으로 분류됩니다.33 데이터와 로직이 엄격하게 분리되지 않았습니다.장단점장점: OOP 배경을 가진 개발자에게 더 직관적입니다. 블루프린트는 디자이너 친화적인 강력한 워크플로우를 제공합니다. 프레임워크가 성숙하고 견고합니다.단점: 하이브리드 모델은 순수 ECS만큼 본질적으로 캐시 친화적이거나 병렬화하기 쉽지 않습니다. 대규모 엔티티 수에 대해 동일한 수준의 성능을 달성하기가 더 어렵습니다.35 하지만 에픽게임즈는 성능이 중요한 부분에 더 많은 DOD/ECS 개념을 통합하고 있습니다.40아키텍처 특징Unity (DOTS/ECS)언리얼 엔진 (액터-컴포넌트)핵심 패러다임데이터 지향 (Data-Oriented) 10컴포지션을 활용한 객체 지향 (Object-Oriented with Composition) 40엔티티 표현경량 정수 ID 13중량 AActor 객체 40컴포넌트 역할순수 데이터 (IComponentData) 32데이터와 로직 (UComponent) 33로직 위치오직 System에만 존재 32Component, Actor 및 기타 클래스에 분산 40데이터 레이아웃기본적으로 SoA (배열의 구조체) 선호 28기본적으로 AoS (구조체의 배열) 선호 26동시성 모델C# 잡 시스템을 통한 명시적 병렬 처리 37엔진이 관리하는 태스크 그래프결론핵심 원칙 요약본 보고서는 현대 게임 프로그래밍을 관통하는 핵심 원칙들을 살펴보았습니다. 성능을 위한 데이터 레이아웃의 중요성(DOD), 상속보다 컴포지션이 제공하는 유연성(Component/ECS), 그리고 유지보수성을 위한 의식적인 디커플링(Observer/Event Queue)이 그것입니다.도구로서의 패턴, 교리가 아닌이러한 패턴들은 도구 상자 속의 도구들임을 강조해야 합니다. 목표는 가능한 많은 패턴을 사용하는 것이 아니라, 당면한 문제를 정확히 이해하고 그에 맞는 올바른 도구를 선택하는 것입니다.14 때로는 완전한 상태 패턴 구현보다 간단한 if 문 하나가 더 나은 해결책일 수 있습니다.63게임 아키텍처의 미래데이터 지향 설계로의 전환 추세는 앞으로도 계속될 것입니다. 이는 CPU의 코어 수가 계속 증가하고, 게임 월드는 더욱 거대하고 복잡해지기를 요구받기 때문입니다. 미래의 아키텍처는 소프트웨어의 문제를 하드웨어의 현실에 더 잘 부합시키는 방향으로 계속해서 진화할 것입니다.
